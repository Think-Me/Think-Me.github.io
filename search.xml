<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>揪出隐藏的病毒进程</title>
      <link href="/post/2024/05/31/56177/"/>
      <url>/post/2024/05/31/56177/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>博主在访问pve web端时偶然发现有个虚拟机CPU占用持续100%！！！于是连接到虚拟机中使用top查看系统资源使用情况，但是CPU占用率显示100%而下方的进程列表中按CPU占用排序并没有高占用进程。所以判断应该是病毒程序使用了某些隐藏手段！</p><h3 id="1-使用unhide找出隐藏进程"><a href="#1-使用unhide找出隐藏进程" class="headerlink" title="1. 使用unhide找出隐藏进程"></a>1. 使用unhide找出隐藏进程</h3><p>先安装unhide <code>apt install unhide</code> 然后执行 <code>unhide proc</code> </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu-template:~# unhide proc</span><br><span class="line">Unhide 20130526</span><br><span class="line">Copyright © 2013 Yago Jesus &amp; Patrick Gouin</span><br><span class="line">License GPLv3+ : GNU GPL version 3 or later</span><br><span class="line">http://www.unhide-forensics.info</span><br><span class="line"></span><br><span class="line">NOTE : This version of unhide is for systems using Linux &gt;= 2.6 </span><br><span class="line"></span><br><span class="line">Used options: </span><br><span class="line">[*]Searching for Hidden processes through /proc stat scanning</span><br><span class="line"></span><br><span class="line">Found HIDDEN PID: 1072</span><br><span class="line">        Cmdline: &quot;-bash&quot;</span><br><span class="line">        Executable: &quot;/usr/bin/-bash (deleted)&quot;</span><br><span class="line">        Command: &quot;-bash&quot;</span><br><span class="line">        $USER=root</span><br><span class="line">        $PWD=/root</span><br><span class="line"></span><br><span class="line">Found HIDDEN PID: 1074</span><br><span class="line">        Cmdline: &quot;-bash&quot;</span><br><span class="line">        Executable: &quot;/usr/bin/-bash (deleted)&quot;</span><br><span class="line">        Command: &quot;-bash&quot;</span><br><span class="line">        $USER=root</span><br><span class="line">        $PWD=/root</span><br><span class="line"></span><br><span class="line">Found HIDDEN PID: 1075</span><br><span class="line">        Cmdline: &quot;-bash&quot;</span><br><span class="line">        Executable: &quot;/usr/bin/-bash (deleted)&quot;</span><br><span class="line">        Command: &quot;-bash&quot;</span><br><span class="line">        $USER=root</span><br><span class="line">        $PWD=/root</span><br><span class="line"></span><br><span class="line">Found HIDDEN PID: 1076</span><br><span class="line">        Cmdline: &quot;-bash&quot;</span><br><span class="line">        Executable: &quot;/usr/bin/-bash (deleted)&quot;</span><br><span class="line">        Command: &quot;-bash&quot;</span><br><span class="line">        $USER=root</span><br><span class="line">        $PWD=/root</span><br><span class="line"></span><br><span class="line">Found HIDDEN PID: 1077</span><br><span class="line">        Cmdline: &quot;-bash&quot;</span><br><span class="line">        Executable: &quot;/usr/bin/-bash (deleted)&quot;</span><br><span class="line">        Command: &quot;-bash&quot;</span><br><span class="line">        $USER=root</span><br><span class="line">        $PWD=/root</span><br><span class="line"></span><br><span class="line">Found HIDDEN PID: 1078</span><br><span class="line">        Cmdline: &quot;-bash&quot;</span><br><span class="line">        Executable: &quot;/usr/bin/-bash (deleted)&quot;</span><br><span class="line">        Command: &quot;-bash&quot;</span><br><span class="line">        $USER=root</span><br><span class="line">        $PWD=/root</span><br><span class="line"></span><br><span class="line">Found HIDDEN PID: 1081</span><br><span class="line">        Cmdline: &quot;-bash&quot;</span><br><span class="line">        Executable: &quot;/usr/bin/-bash (deleted)&quot;</span><br><span class="line">        Command: &quot;-bash&quot;</span><br><span class="line">        $USER=root</span><br><span class="line">        $PWD=/root</span><br></pre></td></tr></table></figure><p>好家伙！这么多隐藏进程！</p><p>现在来看这些隐藏进程的细节都是干嘛的。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu-template:~# systemctl status 1072</span><br><span class="line">● session-1.scope - Session 1 of user root</span><br><span class="line">     Loaded: loaded (/run/systemd/transient/session-1.scope; transient)</span><br><span class="line">  Transient: yes</span><br><span class="line">     Active: active (running) since Fri 2024-05-31 16:40:58 CST; 22s ago</span><br><span class="line">      Tasks: 11</span><br><span class="line">     Memory: 29.7M</span><br><span class="line">     CGroup: /user.slice/user-0.slice/session-1.scope</span><br><span class="line">             ├─ 862 sshd: root@pts/0</span><br><span class="line">             ├─1000 -bash</span><br><span class="line">             ├─1072 -bash</span><br><span class="line">             ├─1470 systemctl status 1072</span><br><span class="line">             └─1472 pager</span><br></pre></td></tr></table></figure><h3 id="2-清理隐藏进程的可执行文件和服务"><a href="#2-清理隐藏进程的可执行文件和服务" class="headerlink" title="2. 清理隐藏进程的可执行文件和服务"></a>2. 清理隐藏进程的可执行文件和服务</h3><p>根据<code>unhide</code>和<code>systemctl status</code>的结果，清理隐藏进程的可执行文件和服务。</p><h3 id="3-使用杀毒软件扫描系统确认是否还有可疑文件"><a href="#3-使用杀毒软件扫描系统确认是否还有可疑文件" class="headerlink" title="3. 使用杀毒软件扫描系统确认是否还有可疑文件"></a>3. 使用杀毒软件扫描系统确认是否还有可疑文件</h3><p>这里可以使用<a href="https://www.clamav.net/"><code>ClamAV</code></a>和<a href="https://www.chkrootkit.org/"><code>Chkrootkit</code></a> 、<a href="https://rkhunter.sourceforge.net/"><code>Rootkit Hunter</code></a>等杀毒软件来扫描系统，确认是否还有可疑文件。</p>]]></content>
      
      
      <categories>
          
          <category> 【可选】 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 【可选】 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决使用GitHub Pages自定义域名后无法正常申请通配符证书的问题</title>
      <link href="/post/2024/01/02/33430/"/>
      <url>/post/2024/01/02/33430/</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>例如：我将 eber.vip 设置为GitHub Pages的自定义域名，并使用CNAME方式接入。在使用acme.sh或其他工具申请通配符证书时，出现了”CAA record for eber.vip prevents issuance”的错误，导致无法申请ssl证书。<br><img src="/../img/acme/errorimg.png" alt="errorimg.png"></p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>当 CA 机构查询 eber.vip 的 CAA 记录时，如果该域名有 CNAME 记录会优先查询 CNAME 指向的地址是否有 CAA 记录，恰巧github.io配置了 CAA, 并且允许 Let’s Encrypt 颁发单域名证书以及允许 Digi Cert 颁发单域名与通配符证书，所以当我们去申请 Let’s Encrypt 免费的通配符证书时会被驳回。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>一共有多种解决方案，我这里列举两个比较好操作的方式，任选其一即可！</p><ol><li>不使用根域作为 GitHub Pages 的自定义域名。</li><li>用A记录接入 GitHub Pages 而不用 CNAME，<a href="https://docs.github.com/zh/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain">参考文档</a>。</li></ol><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://letsencrypt.org/zh-cn/docs/caa/">证书颁发机构授权（CAA）</a></li><li><a href="https://zh.wikipedia.org/wiki/DNS%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%9C%BA%E6%9E%84%E6%8E%88%E6%9D%83">CAA记录</a></li><li><a href="https://cloud.tencent.com/document/product/400/88117">腾讯云文档</a></li><li><a href="https://docs.github.com/zh/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain-and-the-www-subdomain-variant">GitHub文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acme.sh </tag>
            
            <tag> SSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Overlay文件系统</title>
      <link href="/post/2023/12/25/14212/"/>
      <url>/post/2023/12/25/14212/</url>
      
        <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>OverlayFS是一种文件系统，由Miklos Szeredi开发，主要目的是在共同的基础文件系统上建立虚拟化系统。其主要特性是：叠合两种不同的文件系统，一个是只读，另一个可写。这样的特性对用户是透明的，使系统能支持恢复出厂配置等功能。OverlayFS在2014年12月3.18版本中被合并到Linux kernel主线中。著名的OpenWrt和Docker都采用了Overlay技术。</p><h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h3><p><img src="/../img/Overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/overlay1.png" alt="overlay1.png"></p><p>Overlay表示叠加和覆盖的意思。OverlayFS文件系统则如上图所示：OverlayFS的实现方式是使用一个lower层和一个upper层叠加成为work，其中lower是基础文件系统（所有文件直接呈现到work），upper是叠加在lower之上的文件系统（所有文件也呈现到work，但是如果某个文件名与lower中一致则使用upper中的文件）。</p><h3 id="3-实践"><a href="#3-实践" class="headerlink" title="3. 实践"></a>3. 实践</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@hk:~# mkdir -p /overlay/overlaydemo</span><br><span class="line">root@hk:~# cd !$</span><br><span class="line">root@hk:/overlay/overlaydemo# mkdir -p lower upper work merged</span><br><span class="line">root@hk:/overlay/overlaydemo# mkdir -p lower/d1 upper/d1</span><br><span class="line">root@hk:/overlay/overlaydemo# touch lower/f1 upper/f1</span><br><span class="line">root@hk:/overlay/overlaydemo# echo &quot;lower f1&quot;&gt; lower/f1</span><br><span class="line">root@hk:/overlay/overlaydemo# echo &quot;upper f1&quot;&gt; upper/f1</span><br><span class="line">root@hk:/overlay/overlaydemo# touch lower/d1/d1f1 upper/d1/d1f1</span><br><span class="line">root@hk:/overlay/overlaydemo# echo &quot;lower d1 d1f1&quot;&gt; lower/d1/d1f1 </span><br><span class="line">root@hk:/overlay/overlaydemo# echo &quot;upper d1 d1f1&quot;&gt; upper/d1/d1f1</span><br><span class="line">root@hk:/overlay/overlaydemo# touch lower/d1/d1fa upper/d1/d1fb</span><br><span class="line">root@hk:/overlay/overlaydemo# echo &quot;lower d1 d1fa&quot;&gt; lower/d1/d1fa</span><br><span class="line">root@hk:/overlay/overlaydemo# echo &quot;upper d1 d1fb&quot;&gt; upper/d1/d1fb</span><br><span class="line">root@hk:/overlay/overlaydemo# tree # 整个目录结构如下所示</span><br><span class="line">.</span><br><span class="line">├── lower</span><br><span class="line">│   ├── d1</span><br><span class="line">│   │   ├── d1f1</span><br><span class="line">│   │   └── d1fa</span><br><span class="line">│   └── f1</span><br><span class="line">├── merged</span><br><span class="line">│   ├── d1</span><br><span class="line">│   │   ├── d1f1</span><br><span class="line">│   │   ├── d1fa</span><br><span class="line">│   │   └── d1fb</span><br><span class="line">│   └── f1</span><br><span class="line">├── upper</span><br><span class="line">│   ├── d1</span><br><span class="line">│   │   ├── d1f1</span><br><span class="line">│   │   └── d1fb</span><br><span class="line">│   └── f1</span><br><span class="line">└── work</span><br><span class="line">    └── work</span><br><span class="line"></span><br><span class="line">8 directories, 10 files</span><br><span class="line">root@hk:/overlay/overlaydemo# mount -t overlay ol -o lowerdir=lower,upperdir=upper,workdir=work merged</span><br><span class="line">root@hk:/overlay/overlaydemo# df</span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">udev              461724       0    461724   0% /dev</span><br><span class="line">tmpfs              94388   11348     83040  13% /run</span><br><span class="line">/dev/sda1       64860904 2411580  62432940   4% /</span><br><span class="line">tmpfs             471928       0    471928   0% /dev/shm</span><br><span class="line">tmpfs               5120       0      5120   0% /run/lock</span><br><span class="line">tmpfs             471928       0    471928   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda15        106858    3195    103664   3% /boot/efi</span><br><span class="line">/dev/sdb1        4060864    8188   3826680   1% /mnt</span><br><span class="line">tmpfs              94388       0     94388   0% /run/user/0</span><br><span class="line">ol              64860904 2411580  62432940   4% /overlay/overlaydemo/merged</span><br><span class="line">root@hk:/overlay/overlaydemo# tree merged/</span><br><span class="line">merged/</span><br><span class="line">├── d1</span><br><span class="line">│   ├── d1f1</span><br><span class="line">│   ├── d1fa</span><br><span class="line">│   └── d1fb</span><br><span class="line">└── f1</span><br><span class="line"></span><br><span class="line">1 directory, 4 files</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">由上可知 刚才的f1和d1f1这里只有一份而d1fa和d1fb都存在。</span></span><br><span class="line">root@hk:/overlay/overlaydemo# cat merged/d1/d1f1 </span><br><span class="line">upper d1 d1f1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看d1f1文件发现是upper的d1f1内容</span></span><br><span class="line">root@hk:/overlay/overlaydemo# cat merged/d1/d1fa</span><br><span class="line">lower d1 d1fa</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看d1fa文件发现是lower的d1fa内容</span></span><br><span class="line">root@hk:/overlay/overlaydemo# cat merged/d1/d1fb</span><br><span class="line">upper d1 d1fb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看d1fb文件发现是upper的d1fb内容</span></span><br><span class="line">root@hk:/overlay/overlaydemo# cat merged/f1 </span><br><span class="line">upper f1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看f1文件发现是upper的f1内容</span></span><br><span class="line">root@hk:/overlay/overlaydemo# echo &quot;update it...&quot;&gt;&gt; merged/d1/d1fa</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">现在修改 最初只在lower中的文件 -- merged/d1/d1fa</span> </span><br><span class="line">root@hk:/overlay/overlaydemo# cat merged/d1/d1fa </span><br><span class="line">lower d1 d1fa</span><br><span class="line">update it...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现 merged中 文件内容已经更新了</span></span><br><span class="line">root@hk:/overlay/overlaydemo# cat lower/d1/d1fa </span><br><span class="line">lower d1 d1fa</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">而lower中 文件内容 没有更新</span></span><br><span class="line">root@hk:/overlay/overlaydemo# cat upper/d1/d1fa </span><br><span class="line">lower d1 d1fa</span><br><span class="line">update it...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现upper中 多了一个同名文件d1fa 并且内容为修改后的内容。</span></span><br></pre></td></tr></table></figure><h3 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h3><ul><li>-t overlay代表使用overlay文件系统</li><li>ol代表文件系统名称可以随意指定</li><li>lowerdir可以有多个，用:分隔</li><li>upperdir和workdir只能有一个</li><li>workdir必须是个空文件夹，也可以不创建会自动生成</li><li>merged是最终的挂载目录，我这里是当前文件夹的merged目录</li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac上最强虚拟机Parallels Desktop破解版</title>
      <link href="/post/2023/09/21/21181/"/>
      <url>/post/2023/09/21/21181/</url>
      
        <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a><blockquote><p>Parallels Desktop 19 破解版</p></blockquote></h3><p><img src="https://up.eber.vip/Think-Me/img/main/2023/09/1695287042-202309211704100.png"></p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><blockquote><p>属性</p></blockquote></h3><ul><li>名称：Parallels Desktop</li><li>版本：19.0.0</li><li>厂商：Parallels International GmbH</li><li>系统：macOS 10.14.6 and later</li><li>架构：ARM, x86(64-bit)</li></ul><h3 id="-2"><a href="#-2" class="headerlink" title=""></a><blockquote><p>说明</p></blockquote></h3><ul><li>解压之后根据 Crack_Parallels 文件夹中 Read-me.txt 文件进行操作</li><li>在执行 Install_Patch.command 时可能会遇到权限问题，直接在当前目录下打开终端执行 <code>chmod -R 777 *</code> 给予全部权限即可</li></ul><h3 id="-3"><a href="#-3" class="headerlink" title=""></a><blockquote><p>下载</p></blockquote></h3><ul><li><a class="btn-beautify outline green larger" href="https://list.eber.vip:60443/d/Ali189/public/MAC%E8%BD%AF%E4%BB%B6/ParallelsDesktop-19_0_0-54570.zip?sign=CmtXU6AYyfse9XEgX8UFn-llypvbLnc4yIbzYeOvfV8=:1710839279"   title="V19.0.0"><i class="far fa-hand-point-right"></i><span>V19.0.0</span></a></li><li><a class="btn-beautify outline green larger" href="https://list.eber.vip:60443/d/189Cloud/app/ParallelsDesktop-19_0_0-54570.zip?sign=5EI4iGtcyA3hclyAUsPVBkWPn9a__VQRyaV2Dx5aRh4=:1710839254"   title="V19.0.0"><i class="far fa-hand-point-right"></i><span>V19.0.0</span></a></li><li><a class="btn-beautify outline green larger" href="https://list.eber.vip:60443/d/Ali189/public/MAC%E8%BD%AF%E4%BB%B6/ParallelsDesktop-18_1_0-53311_2.tgz?sign=A2p8QNHxTxNq5RK9p9_cadhOcm54p8m-TverIZKf-ck=:1710839313"   title="V18.1.0"><i class="far fa-hand-point-right"></i><span>V18.1.0</span></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 资源分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Navicat Premium 16 Mac破解版</title>
      <link href="/post/2023/09/21/39935/"/>
      <url>/post/2023/09/21/39935/</url>
      
        <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a><blockquote><p>Navicat Premium 16.2.5 Mac破解版</p></blockquote></h3><p><img src="https://up.eber.vip/Think-Me/img/main/2023/09/1695282851-202309211554264.png"></p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><blockquote><p>属性</p></blockquote></h3><ul><li>名称：Navicat Premium</li><li>版本：16.2.5</li><li>厂商：PremiumSoft</li><li>系统：macOS 10.14 and later</li><li>架构：x86(64-bit)</li></ul><h3 id="-2"><a href="#-2" class="headerlink" title=""></a><blockquote><p>说明</p></blockquote></h3><ul><li>无需额外激活操作，直接安装即可使用</li><li>16版本目前有无法保存密码的问题，介意的话可以使用15版本，也可以先用15版本保存完连接配置然后再安装16也是可以的</li><li>破解软件可能需要关闭SIP才能使用，不过不推荐关闭SIP，可以通过以下操作让指定软件绕开开发者公证检查  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo xattr -r -d com.apple.quarantine /Applications/Navicat\ Premium.app</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/Applications/Navicat\ Premium.app替换成你自己的软件路径输入密码回车后即可。</span></span><br><span class="line">sudo spctl --master-disable</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示 设置 -&gt; 隐私与安全性 -&gt; 允许任何来源的应用程序 选项</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="-3"><a href="#-3" class="headerlink" title=""></a><blockquote><p>下载</p></blockquote></h3><ul><li><a class="btn-beautify outline green larger" href="https://list.eber.vip:60443/d/Ali189/public/MAC%E8%BD%AF%E4%BB%B6/Navicat_Premium_16_2_5.dmg?sign=e6VlXeAo-paPEgN_a9019_ps8F4XqUe190epeKSM5ss=:1710836630"   title="V16.2.5"><i class="far fa-hand-point-right"></i><span>V16.2.5</span></a></li><li><a class="btn-beautify outline green larger" href="https://list.eber.vip:60443/d/189Cloud/app/Navicat_Premium_16_2_5.dmg?sign=3sbiq3GyjnE4mEnGPahjr2oEMMAIY1R7EMZw1Db7xEg=:1710837459"   title="V16.2.5"><i class="far fa-hand-point-right"></i><span>V16.2.5</span></a></li><li><a class="btn-beautify outline green larger" href="https://list.eber.vip:60443/d/Ali189/public/MAC%E8%BD%AF%E4%BB%B6/Navicat_Premium_15_0_36_TNT.dmg?sign=980XJDp7mPTbW-9risvteiTe14WzdzOixQpS3dYznl8=:1710917604"   title="V15.0.36"><i class="far fa-hand-point-right"></i><span>V15.0.36</span></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 资源分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis bitmaps学习笔记</title>
      <link href="/post/2023/09/17/49693/"/>
      <url>/post/2023/09/17/49693/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Bitmaps are not an actual data type, but a set of bit-oriented operations defined on the String type which is treated like a bit vector. Since strings are binary safe blobs and their maximum length is 512 MB, they are suitable to set up to 2^32 different bits.</p><p>引用自<a href="https://redis.io/docs/data-types/bitmaps/">官方文档</a>。简单来说就是这个bitmaps不是一个实际的数据类型，而是字符串类型上定义的一组面向bit位操作，最大长度为512MB，可以存储2^32个不同的位。</p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>根据<a href="https://redis.io/commands/?group=bitmap">文档</a>得知Bitmaps一共有7个操作命令，分别是：BITCOUNT BITFIELD BITFIELD_RO BITOP BITPOS GETBIT SETBIT，这里先详细介绍一下常用的几个命令。</p><ol><li><mark class="hl-label orange">✨SETBIT</mark> <ul><li>语法：SETBIT key offset value</li><li>用途：将key的bit下标为offset的值设为value</li><li>文档：<a href="https://redis.io/commands/setbit/">redis.io</a> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 将key1的bit下标为3位(后面简称第0位，第3位...)设值为1</span><br><span class="line">SETBIT key1 3 1</span><br><span class="line">(integer) 0</span><br><span class="line">-- 这里回显的是该位修改之前的数据值</span><br></pre></td></tr></table></figure> <img src="https://up.eber.vip/Think-Me/img/main/2023/09/1694591592-202309131553442.png"><br> 可以看到从左到右第3位的值为1，其余位为0</li></ul><p> 如果此时<code>setbit key1 8 1</code>，则会自动扩容一个字节，扩容后的值为：<br> <img src="https://up.eber.vip/Think-Me/img/main/2023/09/1694591820-202309131557218.png"></p></li><li><mark class="hl-label orange">✨GETBIT</mark> <ul><li>语法：GETBIT key offset</li><li>用途：获取key的bit下标位offset的值</li><li>文档：<a href="https://redis.io/commands/getbit/">redis.io</a> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 获取第3位的值</span><br><span class="line">[db15] &gt; getbit key1 3</span><br><span class="line">(integer) 1</span><br><span class="line">-- 获取第8位的值</span><br><span class="line">[db15] &gt; getbit key1 8</span><br><span class="line">(integer) 1</span><br><span class="line">-- 获取第0位的值</span><br><span class="line">[db15] &gt; getbit key1 0</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></li></ul></li><li><mark class="hl-label orange">✨BITCOUNT</mark> <ul><li>语法：BITCOUNT key [start end [BYTE | BIT]]</li><li>用途：统计所有或指定区间区间内1的数量</li><li>文档：<a href="https://redis.io/commands/bitcount/">redis.io</a> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 再设置几位，便于举例</span><br><span class="line">[db15] &gt; setbit key1 2 1</span><br><span class="line">(integer) 0</span><br><span class="line">[db15] &gt; setbit key1 9 1</span><br><span class="line">(integer) 0</span><br><span class="line">[db15] &gt; setbit key1 12 1</span><br><span class="line">(integer) 0</span><br><span class="line">[db15] &gt; setbit key1 18 1</span><br><span class="line">(integer) 0</span><br><span class="line">[db15] &gt; setbit key1 19 1</span><br><span class="line">(integer) 0</span><br><span class="line">[db15] &gt; setbit key1 20 1</span><br><span class="line">(integer) 0</span><br><span class="line">[db15] &gt; setbit key1 28 1</span><br><span class="line">(integer) 0</span><br><span class="line">[db15] &gt; setbit key1 34 1</span><br><span class="line">(integer) 0</span><br><span class="line">[db15] &gt; setbit key1 36 1</span><br><span class="line">(integer) 0</span><br><span class="line">-- 现在key1的二进制值为 00110000 11001000 00111000 00001000 00101000 便于查看每个字节中间有空格隔开</span><br><span class="line">-- 第一字节有2个1，第二字节有3个1，第三字节有3个1，第四个字节有1个1，第五个字节有2个1，所以总共有11个1</span><br><span class="line">-- 获取所有1的数量</span><br><span class="line">[db15] &gt; bitcount key1</span><br><span class="line">(integer) 11</span><br><span class="line">-- 获取第一字节中1的数量 等同于 bitcount key1 0 0 byte</span><br><span class="line">[db15] &gt; bitcount key1 0 0</span><br><span class="line">(integer) 2</span><br><span class="line">[db15] &gt; bitcount key1 0 0 byte</span><br><span class="line">(integer) 2</span><br><span class="line">-- 获取第0位到第7位的1的数量</span><br><span class="line">[db15] &gt; bitcount key1 0 7 bit</span><br><span class="line">(integer) 2</span><br><span class="line">-- 获取倒数第二字节到倒数第一字节1的数量 注意：一定要是从左往右的顺序</span><br><span class="line">[db15] &gt; bitcount key1 -2 -1</span><br><span class="line">(integer) 3</span><br><span class="line">-- 获取倒数第4位到倒数第1位1的数量  由此可得 正向下标是从0开始计数，而倒数是从1开始计数</span><br><span class="line">[db15] &gt; bitcount key1 -4 -1 bit</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li></ul></li><li><mark class="hl-label orange">✨BITPOS</mark> <ul><li>语法：BITPOS key bit [start [end [BYTE | BIT]]]</li><li>用途：获取所有或指定区间内第一个指定bit值[0 | 1]的下标</li><li>文档：<a href="https://redis.io/commands/bitpos/">redis.io</a> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- key1: 00110000 11001000 00111000 00001000 00101000</span><br><span class="line">-- 获取第一个0值的下标</span><br><span class="line">[db15] &gt; bitpos key1 0</span><br><span class="line">(integer) 0</span><br><span class="line">-- 获取第一个1值的下标</span><br><span class="line">[db15] &gt; bitpos key1 1</span><br><span class="line">(integer) 2</span><br><span class="line">-- 从第1位开始到第四位的第一个1的下标 这里的下标还是总数据的下标</span><br><span class="line">[db15] &gt; bitpos key1 1 1 4 bit</span><br><span class="line">(integer) 2</span><br><span class="line">-- 如果没有则返回-1 如果key不存在也返回-1</span><br><span class="line">[db15] &gt; bitpos key1 1 4 6 bit</span><br><span class="line">(integer) -1</span><br><span class="line">-- 从第二字节到第二字节的第一个1的下标</span><br><span class="line">[db15] &gt; bitpos key1 1 2 2 byte</span><br><span class="line">(integer) 18</span><br></pre></td></tr></table></figure></li></ul></li><li><mark class="hl-label orange">✨BITOP</mark> <ul><li>语法：BITOP &lt;AND | OR | XOR | NOT&gt; destkey key [key …]</li><li>用途：对多个key进行位运算(与 &amp;，或 |，异或 ^，非或者叫取反 ~)，结果保存到destkey中</li><li>文档：<a href="https://redis.io/commands/bitop/">redis.io</a> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[db15] &gt; setbit op1 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">[db15] &gt; setbit op1 3 1</span><br><span class="line">(integer) 0</span><br><span class="line">[db15] &gt; setbit op1 5 1</span><br><span class="line">(integer) 0</span><br><span class="line">[db15] &gt; setbit op2 4 1</span><br><span class="line">(integer) 0</span><br><span class="line">[db15] &gt; setbit op2 6 1</span><br><span class="line">(integer) 0</span><br><span class="line">[db15] &gt; bitop and d1 op1 op2</span><br><span class="line">(integer) 1</span><br><span class="line">-- op1: 01010100</span><br><span class="line">-- op2: 00001010</span><br><span class="line">-- d1:  00000000</span><br><span class="line">[db15] &gt; bitop or d2 op1 op2</span><br><span class="line">(integer) 1</span><br><span class="line">-- d2: 01011110</span><br><span class="line">[db15] &gt; bitop xor d3 op1 op2</span><br><span class="line">(integer) 1</span><br><span class="line">-- d3: 01011110</span><br><span class="line">[db15] &gt; bitop not d4 op1</span><br><span class="line">(integer) 1</span><br><span class="line">-- d4: 10101011</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>由上述的操作命令可以看出，Bitmaps的应用场景主要是统计和判断，比如签到，活跃用户，用户在线状态等等。这里以签到为例，假设有一个用户id为1，每天签到一次，那么可以用一个key来存储用户的签到情况，比如key为sign:1，可以处理的场景大概有：</p><ul><li>用户签到</li><li>查询用户某天是否签到</li><li>统计指定用户的累计签到天数</li><li>…… 自己发挥想象<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 用户签到  记录用户ID为1的用户第一天签到</span><br><span class="line">[db15] &gt; setbit sign:1 0 1</span><br><span class="line">-- 用户签到  记录用户ID为1的用户第二天签到 后面以此类推</span><br><span class="line">[db15] &gt; setbit sign:1 1 1</span><br><span class="line"></span><br><span class="line">-- 查询用户ID为1的用户第一天是否签到</span><br><span class="line">[db15] &gt; getbit sign:1 0</span><br><span class="line"></span><br><span class="line">-- 统计用户ID为1的用户的累计签到天数</span><br><span class="line">[db15] &gt; bitcount sign:1</span><br><span class="line"></span><br><span class="line">-- 统计用户ID为1的用户在前七天的签到情况</span><br><span class="line">[db15] &gt; bitcount sign:1 0 6</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="留个坑等后面填"><a href="#留个坑等后面填" class="headerlink" title="留个坑等后面填"></a>留个坑等后面填</h3><p>BITFIELD 和 BITFIELD_RO 的详细使用暂时没有介绍，等后续有时间再补充！</p>]]></content>
      
      
      <categories>
          
          <category> 开发与测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>brew安装指定版本软件</title>
      <link href="/post/2023/08/09/41685/"/>
      <url>/post/2023/08/09/41685/</url>
      
        <content type="html"><![CDATA[<h2 id="brew安装指定版本软件"><a href="#brew安装指定版本软件" class="headerlink" title="brew安装指定版本软件"></a>brew安装指定版本软件</h2><ul><li>该教程一共就两步，非常简单，但是很多人都不知道，所以写下来，方便大家查阅。这里用tailscale为例，其他软件也是一样的。</li></ul><ol><li><p>找到软件对应版本的rb文件</p><p> 访问<a href="https://formulae.brew.sh/">brew</a>官网，在搜索框里搜软件名称，如下图所示：<br><img src="/../img/brew/1691566585-202308091536730.png" alt="1691566585-202308091536730.png"><br> 点击上图中红框圈起来的<mark class="hl-label pink">tailscale.rb</mark> ，进入github，如下图所示：<br><img src="/../img/brew/1691566704-202308091538628.png" alt="1691566704-202308091538628.png"><br> 点击上图中红框圈起来的<mark class="hl-label pink">History</mark> ，进入rb文件的提交历史，如下图所示：<br><img src="/../img/brew/1691566855-202308091540352.png" alt="1691566855-202308091540352.png"><br> 比如现在tailscale的最新版本是1.46.1，我想安装1.44.2。那么就去点击上图中红框圈起来的按钮，进入该版本rb文件预览，如下图所示：<br><img src="/../img/brew/1691566998-202308091543075.png" alt="1691566998-202308091543075.png"><br> 点击上图中红框圈起来的下载按钮即可得到该版本的rb文件。</p></li><li><p>安装rb文件对应版本的软件</p><p> 打开终端，执行<code>brew install --formula /path/to/tailscale.rb</code>即可安装指定版本的软件。</p></li></ol><ul><li>注意：tailscale.rb的路径一定不要搞错，并且rb文件名必须为软件包的名称，不能自己随意修改名称。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发与测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> brew </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将ChatGPT对接到飞书或钉钉2-创建模型并对接</title>
      <link href="/post/2023/08/08/49000/"/>
      <url>/post/2023/08/08/49000/</url>
      
        <content type="html"><![CDATA[<h2 id="一、-创建Azure-OpenAI模型"><a href="#一、-创建Azure-OpenAI模型" class="headerlink" title="一、 创建Azure OpenAI模型"></a>一、 创建Azure OpenAI模型</h2><ol><li>在搜索框中直接搜openai，然后点击进入，如下图所示：<br><img src="https://up.eber.vip/Think-Me/img/main/2023/08/1691054260-202308031717925.png"></li><li>点击上图页面上的创建Azure OpenAI按钮跳转到如下页面：<br><img src="https://up.eber.vip/Think-Me/img/main/2023/08/1691483756-202308081635082.png"></li><li>点击”下一步”，跳转到如下页面：这里选择所有网络即可<br><img src="https://up.eber.vip/Think-Me/img/main/2023/08/1691549015-202308091043852.png"></li><li>后面的都是默认的，最后点击创建：<br><img src="https://up.eber.vip/Think-Me/img/main/2023/08/1691549133-202308091045549.png"></li><li>部署完成后，点击”转到资源”到如下页面：记录一下<mark class="hl-label pink">终结点</mark> 和理密钥中<mark class="hl-label pink">密钥1或密钥2</mark> ，后面会用到<br><img src="https://up.eber.vip/Think-Me/img/main/2023/08/1691549539-202308091052043.png"><br><img src="https://up.eber.vip/Think-Me/img/main/2023/08/1691549643-202308091054146.png"></li><li>再点击上图左侧”模型部署”进入Azure OpenAI Studio页面：这里记录一下<mark class="hl-label pink">部署名</mark> 后面要用到<br><img src="https://up.eber.vip/Think-Me/img/main/2023/08/1691549845-202308091057363.png"></li><li>创建完成之后点击左侧”聊天”菜单，随便输出一句话点击”发送”，然后点击”查看代码”：<br><img src="https://up.eber.vip/Think-Me/img/main/2023/08/1691550170-202308091102357.png"><br><img src="https://up.eber.vip/Think-Me/img/main/2023/08/1691550247-202308091104331.png"></li><li>记录一下代码中的openai.api_version的值，我这里是<mark class="hl-label pink">2023-03-15-preview</mark> </li><li>OK，现在需要的参数都已经获取完毕！下面就是正式对接飞书或钉钉了。</li></ol><h2 id="二、-对接飞书"><a href="#二、-对接飞书" class="headerlink" title="二、 对接飞书"></a>二、 对接飞书</h2><ol><li>飞书开发者平台的操作在<a href="https://github.com/ConnectAI-E/Feishu-OpenAI#%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4">GitHub</a>上已经有教程了，这里不再赘述。</li><li>使用docker方式部署ConnectAI-E&#x2F;Feishu-OpenAI项目，由于作者没有打镜像，这里使用我构建的镜像即可。把{}中的内容替换成你自己的即可。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name feishu-chatgpt -p 9000:9000 \</span><br><span class="line">--env APP_ID=&#123;飞书应用凭证中的 App Id&#125; \</span><br><span class="line">--env APP_SECRET=&#123;飞书应用凭证中的 App Secret&#125; \</span><br><span class="line">--env APP_ENCRYPT_KEY=&#123;飞书应用-事件订阅中的 Encrypt Key&#125; \</span><br><span class="line">--env APP_VERIFICATION_TOKEN=&#123;飞书应用-事件订阅中的 Verification Token&#125; \</span><br><span class="line">--env BOT_NAME=&#123;飞书应用-机器人的名字&#125; \</span><br><span class="line">--env AZURE_ON=true \</span><br><span class="line">--env AZURE_API_VERSION=&#123;前面第8步获取的openai.api_version 我的是2023-03-15-preview&#125; \</span><br><span class="line">--env AZURE_RESOURCE_NAME=&#123;前面第5步获取的终结点域名的前缀 我的是eber-test1&#125; \</span><br><span class="line">--env AZURE_DEPLOYMENT_NAME=&#123;前面第6步获取的部署名 我的是ebervip&#125; \</span><br><span class="line">--env AZURE_OPENAI_TOKEN=&#123;前面第5步获取的密钥1或密钥2&#125; \</span><br><span class="line">717160040/openai:feishu.v1 # 这里镜像名默认是arm的，如果是amd64的请使用717160040/openai:feishu_amd64_v1</span><br></pre></td></tr></table></figure></li></ol><ul><li>全部搞定后，可以在飞书群中将机器人拉入群，然后@机器人触发。如下图所示：<br><img src="https://up.eber.vip/Think-Me/img/main/2023/08/1691551529-202308091125102.png"></li><li>也可以私聊。注意连续对话需要用回复的方式回复机器人，否则机器人会认为是新的对话。</li><li>发送帮助则可以查看一些特定指令：<br><img src="https://up.eber.vip/Think-Me/img/main/2023/08/1691551684-202308091128584.png"></li></ul><h2 id="三、-对接钉钉"><a href="#三、-对接钉钉" class="headerlink" title="三、 对接钉钉"></a>三、 对接钉钉</h2><ol><li>同样钉钉开发者平台的操作在<a href="https://github.com/ConnectAI-E/Dingtalk-OpenAI#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E6%B7%BB%E5%8A%A0%E5%BA%94%E7%94%A8">GitHub</a>上已经有教程了，这里不再赘述。</li><li>点击这里下载<a href="https://raw.githubusercontent.com/ConnectAI-E/Dingtalk-OpenAI/main/docker-compose.yml">docker-compose.yml</a>，这里我们用docker-compose方式部署ConnectAI-E&#x2F;Dingtalk-OpenAI项目。参照下面的描述去修改下载的yml文件，下面我只列出需要修改的配置项，特别要注意带⚠️的配置项。<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">   <span class="attr">chatgpt:</span></span><br><span class="line">      <span class="attr">container_name:</span> <span class="string">chatgpt</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/ali_eryajf/chatgpt-dingtalk</span></span><br><span class="line">      <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">      <span class="attr">environment:</span></span><br><span class="line">         <span class="attr">APIKEY:</span>   <span class="comment"># ⚠️我们用的是azure，这里直接留空</span></span><br><span class="line">         <span class="attr">RUN_MODE:</span> <span class="string">&quot;stream&quot;</span>  <span class="comment"># 运行模式，http 或者 stream ，强烈建议你使用stream模式，通过此链接了解：https://open.dingtalk.com/document/isvapp/stream</span></span><br><span class="line">         <span class="attr">BASE_URL:</span> <span class="string">&quot;&quot;</span>  <span class="comment"># ⚠️我们用的是azure，这里直接留空</span></span><br><span class="line">         <span class="attr">MODEL:</span> <span class="string">&quot;&quot;</span> <span class="comment"># ⚠️我们用的是azure，这里直接留空</span></span><br><span class="line">         <span class="attr">DEFAULT_MODE:</span> <span class="string">&quot;串聊&quot;</span> <span class="comment"># 指定默认的对话模式，可根据实际需求进行自定义，如果不设置，默认为单聊，即无上下文关联的对话模式</span></span><br><span class="line">         <span class="attr">PORT:</span> <span class="number">8090</span> <span class="comment"># 指定服务启动端口，默认为 8090，容器化部署时，不需要调整，一般在二进制宿主机部署时，遇到端口冲突时使用，如果run_mode为stream模式，则可以忽略该配置项</span></span><br><span class="line">         <span class="attr">SERVICE_URL:</span> <span class="string">&quot;http://1.1.1.1:8090&quot;</span>  <span class="comment"># ⚠️服务的地址 例如你服务器IP是1.1.1.1 则为http://1.1.1.1:8090</span></span><br><span class="line">         <span class="attr">CHAT_TYPE:</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">         <span class="attr">APP_SECRETS:</span> <span class="string">&quot;&#123;钉钉机器人在应用信息中的AppSecret&#125;&quot;</span> <span class="comment"># 钉钉机器人在应用信息中的AppSecret，为了校验回调的请求是否合法，如果留空，将会忽略校验，则该接口将会存在其他人也能随意调用的安全隐患，因此强烈建议配置正确的secret，如果你的服务对接给多个机器人，这里可以配置多个机器人的secret，比如 &quot;xxxx,yyyy&quot;</span></span><br><span class="line">         <span class="attr">SENSITIVE_WORDS:</span> <span class="string">&quot;&quot;</span> <span class="comment"># 敏感词，提问时触发，则不允许提问，回答的内容中触发，则以 🚫 代替</span></span><br><span class="line">         <span class="attr">AZURE_ON:</span> <span class="string">&quot;true&quot;</span> <span class="comment"># ⚠️是否走Azure OpenAi API, 默认false ,如果为true，则需要配置下边的四个参数</span></span><br><span class="line">         <span class="attr">AZURE_API_VERSION:</span> <span class="string">&quot;&quot;</span> <span class="comment"># ⚠️参考上面飞书的配置说明</span></span><br><span class="line">         <span class="attr">AZURE_RESOURCE_NAME:</span> <span class="string">&quot;&quot;</span> <span class="comment"># ⚠️参考上面飞书的配置说明</span></span><br><span class="line">         <span class="attr">AZURE_DEPLOYMENT_NAME:</span> <span class="string">&quot;&quot;</span> <span class="comment"># ⚠️参考上面飞书的配置说明</span></span><br><span class="line">         <span class="attr">AZURE_OPENAI_TOKEN:</span> <span class="string">&quot;&quot;</span> <span class="comment"># ⚠️参考上面飞书的配置说明</span></span><br><span class="line">         <span class="attr">DINGTALK_CREDENTIALS:</span> <span class="string">&quot;xxx:xxxxxxxxxxxxxx&quot;</span> <span class="comment"># ⚠️ # 钉钉应用访问凭证，比如 client_id1:secret1 是需要把这俩拼一起的，中间用冒号隔开，如果你的服务对接给多个机器人，这里可以配置多个机器人的凭证，比如 &quot;client_id1:secret1,client_id2:secret2&quot;</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">         <span class="bullet">-</span> <span class="string">./data:/app/data</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">         <span class="bullet">-</span> <span class="string">&quot;8090:8090&quot;</span></span><br><span class="line">      <span class="attr">extra_hosts:</span></span><br><span class="line">         <span class="bullet">-</span> <span class="string">host.docker.internal:host-gateway</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>同样，全部搞定后，可以在钉钉群中将机器人拉入群，然后@机器人触发或者私聊触发。如下图所示：<br><img src="https://up.eber.vip/Think-Me/img/main/2023/08/1691552985-202308091149467.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT </tag>
            
            <tag> OpenAI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将ChatGPT对接到飞书或钉钉1-申请Azure OpenAI</title>
      <link href="/post/2023/08/03/49000/"/>
      <url>/post/2023/08/03/49000/</url>
      
        <content type="html"><![CDATA[<h2 id="一、-注册Azure账号"><a href="#一、-注册Azure账号" class="headerlink" title="一、 注册Azure账号"></a>一、 注册Azure账号</h2><p>点击这里 <a href="https://portal.azure.com/">Azure</a> 进入Azure官网，注册一个账号，注册时需要绑定一张信用卡，但是不会扣费，只是为了验证你的身份。</p><ul><li>如果你没有信用卡，可以使用 <a href="https://privacy.com/">Privacy</a> 生成一张虚拟信用卡，然后绑定到Azure账号上。</li><li>如果你有Azure100美刀的学生订阅，可以直接使用学生订阅的账号。</li></ul><h2 id="二、-准备申请"><a href="#二、-准备申请" class="headerlink" title="二、 准备申请"></a>二、 准备申请</h2><ol><li>在搜索框中直接搜openai，然后点击进入，如下图所示：<br><img src="https://up.eber.vip/Think-Me/img/main/2023/08/1691054260-202308031717925.png"></li><li>点击上图页面上的创建Azure OpenAI按钮跳转到如下页面：<br><img src="https://up.eber.vip/Think-Me/img/main/2023/08/1691054450-202308031720387.png"></li><li>点击”单击此处请求访问Azure OpenAI服务”，跳转到如下页面：<br><img src="https://up.eber.vip/Think-Me/img/main/2023/08/1691054655-202308031724685.png"></li><li>填写对应信息即可申请</li><li>提交申请后，会收到一封邮件，如下图所示：<br><img src="https://up.eber.vip/Think-Me/img/main/2023/08/1691055022-202308031730342.png"></li><li>大概一个工作日就会收到结果，成功的邮件如下所示：<br><img src="https://up.eber.vip/Think-Me/img/main/2023/08/1691055165-202308031732786.png"></li></ol><h2 id="三、-申请注意事项"><a href="#三、-申请注意事项" class="headerlink" title="三、 申请注意事项"></a>三、 申请注意事项</h2><ol><li>大部分问题都随便填写即可，只要不是太离谱就行。</li><li>订阅ID一定一定一定不要填写错误！<br><img src="https://up.eber.vip/Think-Me/img/main/2023/08/1691054970-202308031729943.png"></li><li>这里的邮箱一定要填写企业邮箱(可以是自己搭建的域名邮箱)<br><img src="https://up.eber.vip/Think-Me/img/main/2023/08/1691054790-202308031726926.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT </tag>
            
            <tag> OpenAI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Action使用自有服务器跑任务</title>
      <link href="/post/2023/06/30/43308/"/>
      <url>/post/2023/06/30/43308/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>接上回书 <a href="https://eber.vip/post/2023/04/14/17500/">《GitHub Action笔记》</a> ，官方是有一定免费额度的，如果这个额度不够怎么办？或者是自己想要一个满足自己特定需求的定制化workflow服务器怎么办？</p><p>本次我们就主要讲述如何使用自己的服务器跑GitHub Action任务。本文参照的是 <a href="https://docs.github.com/zh/actions/hosting-your-own-runners/managing-self-hosted-runners/adding-self-hosted-runners">官方文档-添加自托管的运行器</a>。</p><h3 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h3><p>首先我们需要一台服务器，这里我使用的是 <mark class="hl-label pink">Oracle新加坡</mark>  X86_64架构的服务器，配置为2C1G。</p><p>根据文档介绍我们需要到对应的仓库的设置中找到 <code>Actions</code>，然后点击 <code>runner</code>，然后根据提示下载对应的运行器。如下图所示：</p><p><img src="https://up.eber.vip/Think-Me/img/main/2023/06/1688109001-202306301510042.png"></p><p>接下来就是无脑执行提示的命令就行了[不要照抄我的，不要照抄我的，不要照抄我的] 用你自己页面上实际显示的命令</p><ul><li><p>下载解压</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line"><span class="built_in">mkdir</span> actions-runner &amp;&amp; <span class="built_in">cd</span> actions-runner</span><br><span class="line"><span class="comment"># 下载最新的runner包</span></span><br><span class="line">curl -o actions-runner-linux-x64-2.305.0.tar.gz -L https://github.com/actions/runner/releases/download/v2.305.0/actions-runner-linux-x64-2.305.0.tar.gz</span><br><span class="line"><span class="comment"># 校验文件hash值 一般如果网络没啥问题直接顺利下载完成可跳过这一步</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;737bdcef6287a11672d6a5a752d70a7c96b4934de512b7eb283be6f51a563f2f  actions-runner-linux-x64-2.305.0.tar.gz&quot;</span> | <span class="built_in">sha256sum</span> -c</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar xzf ./actions-runner-linux-x64-2.305.0.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建runner并配置  这里注意不能使用root权限的账户运行 XXX是你页面上显示的token</span></span><br><span class="line">./config.sh --url https://github.com/Think-Me/hexo --token XXX</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会有下面的交互提醒 没有特殊需求的话直接全回车用默认就行了</span></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">|        ____ _ _   _   _       _          _        _   _                      |</span><br><span class="line">|       / ___(_) |_| | | |_   _| |__      / \   ___| |_(_) ___  _ __  ___      |</span><br><span class="line">|      | |  _| | __| |_| | | | | <span class="string">&#x27;_ \    / _ \ / __| __| |/ _ \| &#x27;</span>_ \/ __|     |</span><br><span class="line">|      | |_| | | |_|  _  | |_| | |_) |  / ___ \ (__| |_| | (_) | | | \__ \     |</span><br><span class="line">|       \____|_|\__|_| |_|\__,_|_.__/  /_/   \_\___|\__|_|\___/|_| |_|___/     |</span><br><span class="line">|                                                                              |</span><br><span class="line">|                       Self-hosted runner registration                        |</span><br><span class="line">|                                                                              |</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># Authentication</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">√ Connected to GitHub</span><br><span class="line"></span><br><span class="line"><span class="comment"># Runner Registration</span></span><br><span class="line"></span><br><span class="line">Enter the name of the runner group to add this runner to: [press Enter <span class="keyword">for</span> Default] </span><br><span class="line"></span><br><span class="line">Enter the name of runner: [press Enter <span class="keyword">for</span> debian] debian11 </span><br><span class="line"></span><br><span class="line">This runner will have the following labels: <span class="string">&#x27;self-hosted&#x27;</span>, <span class="string">&#x27;Linux&#x27;</span>, <span class="string">&#x27;X64&#x27;</span> </span><br><span class="line">Enter any additional labels (ex. label-1,label-2): [press Enter to skip] </span><br><span class="line"></span><br><span class="line">√ Runner successfully added</span><br><span class="line">√ Runner connection is good</span><br><span class="line"></span><br><span class="line"><span class="comment"># Runner settings</span></span><br><span class="line"></span><br><span class="line">Enter name of work folder: [press Enter <span class="keyword">for</span> _work] </span><br><span class="line"></span><br><span class="line">√ Settings Saved.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行runner</span></span><br><span class="line">./run.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回显如下即为启动成功</span></span><br><span class="line">? Connected to GitHub</span><br><span class="line"></span><br><span class="line">Current runner version: <span class="string">&#x27;2.305.0&#x27;</span></span><br><span class="line">2023-06-30 07:57:15Z: Listening <span class="keyword">for</span> Jobs</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>刷新GitHub中runners页面也会发现这个节点已经显示出来了。</p></li></ul><p><img src="https://up.eber.vip/Think-Me/img/main/2023/06/1688111932-202306301558897.png"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用该节点的时候只需要在workflow配置文件中设置 runs-on: [self-hosted, Linux, X64] （根据你自己的节点标签填写）即可。</p><p>我这里为了解决ServerStatus每次增加新的监控节点都需要服务端改配置文件然后再手动重启的问题，所以我在GitHub Action中使用了自己的节点，这样就可以将服务端的操作自动化了（只要我idea中提交修改后的配置文件GitHub Action会自动完成配置文件拉取和重启服务端）。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">自动拉取ServerStatus配置文件并重启服务端</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ServerStatus</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">job1:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">连接vps进行文件拉取并重启服务端</span></span><br><span class="line">    <span class="attr">runs-on:</span> [<span class="string">self-hosted</span>, <span class="string">Linux</span>, <span class="string">X64</span>]</span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SSH</span> <span class="string">Command</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">appleboy/ssh-action@v0.1.10</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">host:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.VPS_OCIN_HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">port:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.VPS_OCIN_PORT</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.VPS_OCIN_USERNAME</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.VPS_OCIN_PASSWORD</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">script:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            cd /opt/ServerStatus/hexo/ &amp;&amp; git pull origin ServerStatus</span></span><br><span class="line"><span class="string">            cp -f /opt/ServerStatus/hexo/config.toml /opt/ServerStatus/config.toml</span></span><br><span class="line"><span class="string">            systemctl restart stat_server.service</span></span><br></pre></td></tr></table></figure><h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><ol><li><p>我这里刚兴冲冲的尝试第一次构建的时候就失败了，如图所示：</p><p> <img src="https://up.eber.vip/Think-Me/img/main/2023/06/1688112527-202306301608600.png"></p><p> 因为我这里用到了一些依赖docker的steps，所以需要安装docker，这里我就直接安装了docker.io。 <code>apt install docker.io</code></p></li><li><p>我又满怀期待的尝试了一次，结果还是失败了，如图所示：</p><p><img src="https://up.eber.vip/Think-Me/img/main/2023/06/1688112652-202306301610311.png"></p><p> 这次是提示没有使用docker的权限，这里我又将debian用户加入到了docker用户组中。 <code>gpasswd -a debian docker</code></p></li><li><p>ok，我又赶紧提交一下代码测试，最终成功将任务执行完毕！</p><p> GitHub显示如下：<br><img src="https://up.eber.vip/Think-Me/img/main/2023/06/1688112732-202306301612554.png"></p><p> 服务器显示如下：<br><img src="https://up.eber.vip/Think-Me/img/main/2023/06/1688113403-202306301623947.png"></p></li></ol><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>到这里其实已经能使用了，这里主要讲一下优化措施（根据你的需求任选其一即可）。</p><p>例如：</p><pre><code>1. 使用screen或其他工具放到后台运行。2. 使用supervisor、pm2或其他工具接管。3. 自己封装成service用systemctl接管。</code></pre><p>具体可参考 <a href="https://blog.eber.vip/post/2020/07/04/30705/">这篇文章</a> !</p>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub Actions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS反射放大攻击1(Golang版)-了解并构建DNS请求</title>
      <link href="/post/2023/06/10/7837/"/>
      <url>/post/2023/06/10/7837/</url>
      
        <content type="html"><![CDATA[<h2 id="DNS请求数据包解析"><a href="#DNS请求数据包解析" class="headerlink" title="DNS请求数据包解析"></a>DNS请求数据包解析</h2><p><img src="https://up.eber.vip/Think-Me/img/main/2023/06/1686290159-202306091355193.png" alt="DNS请求数据包图示"></p><ol><li>如上图所示，DNS数据包由DNS头部和DNS数据部分组成，DNS头部包含了DNS数据包的基本信息，DNS数据部分包含了DNS数据包的具体数据。</li><li>DNS头部(在截图左侧上红框内)包含了12个字节，具体如下：<ol><li>2字节的标识符(Transaction Id)，用于标识DNS请求和响应数据包，响应数据包的标识符和请求数据包的标识符一致。</li><li>2字节的标志位(Flags)，用于标识DNS数据包的类型，如下：<br>   <img src="https://up.eber.vip/Think-Me/img/main/2023/06/1686290497-202306091401219.png" alt="Flags标志位截图"><ol><li>QR(1bit) 查询应答标志，0表示这是查询报文，1表示这是应答报文。</li><li>opcode(4bit) 查询应答类型，0表示标准查询，1表示反向查询，2表示请求服务器状态。</li><li>AA(1bit) 表示权威回答( authoritative answer )，意味着当前查询结果是由域名的权威服务器给出的，仅由应答报文使用。</li><li>TC(1bit) 位表示截断( truncated )，使用 UDP 时，如果应答超过 512 字节，只返回前 512 个字节，仅当DNS报文使用UDP服务时使用。DNS 协议使用UDP服务，但也明确了 『当 DNS 查询被截断时，应该使用 TCP 协议进行重试』 这一规范。</li><li>RD(1bit) 表示递归查询标志 ( recursion desired )，在请求中设置，并在应答中返回。该位为 1 时，服务器必须处理这个请求：如果服务器没有授权回答，它必须替客户端请求其他 DNS 服务器，这也是所谓的 递归查询； 该位为 0 时，如果服务器没有授权回答，它就返回一个能够处理该查询的服务器列表给客户端，由客户端自己进行 迭代查询。</li><li>RA(1bit) 位表示可递归 ( recursion available )，如果服务器支持递归查询，就会在应答中设置该位，以告知客户端。仅由应答报文使用。</li><li>zero(3bit) 这三位未使用，固定为0。</li><li>rcode(4bit) 表示返回码（reply code），用来返回应答状态，常用返回码：0表示无错误，2表示格式错误，3表示域名不存在。</li></ol></li><li>2字节的DNS请求查询域名数量，标识DNS请求数据包中的问题数，通常一次查询查一个域名(为1)。</li><li>2字节的DNS响应记录数，标识DNS响应数据包中的资源记录数，一般为1，分区域解析或负载均衡等情况下会有多个结果。</li><li>2字节的授权资源记录数，标识DNS响应数据包中的授权资源记录数，通常为0。</li><li>2字节的额外资源记录数，标识DNS响应数据包中的额外资源记录数，通常为0。</li></ol></li></ol><h2 id="DNS响应数据包解析"><a href="#DNS响应数据包解析" class="headerlink" title="DNS响应数据包解析"></a>DNS响应数据包解析</h2><p>响应包和请求包没有太大的差别</p><ol><li>响应包中的Answer RRs会根据实际结果展示数量，这个值在请求包中是。</li><li>响应包中的尾部追加了响应数据，如下图所示：<br><img src="https://up.eber.vip/Think-Me/img/main/2023/06/1686290856-202306091407376.png" alt="DNS响应数据包图示"></li></ol><p>由上述请求包和响应包描述可知：响应包因为含有响应数据，所以会比请求包大。并且响应结果越多的域名相应的响应包的大小也会越大。这里就是DNS反射放大攻击的<mark class="hl-label red">放大</mark> 原理，通过构造一个小的请求包，然后通过DNS服务器响应一个大的响应包，从而达到放大的效果。</p><h2 id="DNS请求数据包构造"><a href="#DNS请求数据包构造" class="headerlink" title="DNS请求数据包构造"></a>DNS请求数据包构造</h2><mark class="hl-label orange">✨温馨提示：</mark> <p><strong>配合博文配套<a href="https://github.com/Think-Me/blackhat-tools/tree/main/dns">项目</a>食用更佳！</strong></p><p><strong>DNS请求数据包的构造，主要是按照DNS协议的规定构造出DNS头部和DNS请求数据部分。</strong></p><ol><li>构造DNS数据包需要的结构体 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DNSData DNS数据包结构体</span></span><br><span class="line"><span class="keyword">type</span> DNSData <span class="keyword">struct</span> &#123;</span><br><span class="line">    TransactionId <span class="type">uint16</span> <span class="comment">// 属于header 客户端随机生成的一个无符号整数，范围是0~2^16(0~65536)。在响应头里面也会返回这个值作用是校验。如果值不相等，丢弃响应内容。</span></span><br><span class="line">    Flags         <span class="type">uint16</span> <span class="comment">// 属于header 16位标志位，包含QR、opcode、AA、TC、RD、RA、zero、rcode。一般查询flags为 00000001 00000000</span></span><br><span class="line">    Queries []dnsQuestion <span class="comment">// 本身不属于header 表示查询请求记录内容数据，他的组数长度值为Questions(属于header)</span></span><br><span class="line">    <span class="comment">// 下面几个是应答记录中的内容，只有在应答消息中才会出现</span></span><br><span class="line">    Answers       []dnsAnswer <span class="comment">// 本身不属于header 应答资源记录数据（answer resource record, answer RR）此项只在DNS应答消息中存在，他的数组长度值为AnswerRRs(属于header)</span></span><br><span class="line">    AuthorityRRs  <span class="type">uint16</span>      <span class="comment">// 属于header 授权资源记录数量（authority resource record, authority RR）此项只在DNS应答消息中存在</span></span><br><span class="line">    AdditionalRRs <span class="type">uint16</span>      <span class="comment">// 属于header 附加资源记录数量（additional resource record, additional RR）此项只在DNS应答消息中存在</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flags赋值方法  因为zero这3bit位固定为0，所以不需要赋值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dDNSData *DNSData)</span></span> SetFlag(QR <span class="type">uint16</span>, Opcode <span class="type">uint16</span>, AA <span class="type">uint16</span>, TC <span class="type">uint16</span>, RD <span class="type">uint16</span>, RA <span class="type">uint16</span>, Rcode <span class="type">uint16</span>) &#123;</span><br><span class="line">    dDNSData.Flags = QR&lt;&lt;<span class="number">15</span> + Opcode&lt;&lt;<span class="number">11</span> + AA&lt;&lt;<span class="number">10</span> + TC&lt;&lt;<span class="number">9</span> + RD&lt;&lt;<span class="number">8</span> + RA&lt;&lt;<span class="number">7</span> + Rcode <span class="comment">// 采用位运算符进行赋值到对应bit位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义请求数据的结构体</span></span><br><span class="line"><span class="keyword">type</span> dnsQuestion <span class="keyword">struct</span> &#123;</span><br><span class="line">    QueriesName  <span class="type">string</span> <span class="string">`net:&quot;domain-name&quot;`</span> <span class="comment">// 要查询的域名</span></span><br><span class="line">    QueriesType  <span class="type">uint16</span> <span class="comment">// 查询类型 1:A 2:NS 5:CNAME 6:SOA 12:PTR 15:MX 16:TXT 28:AAAA</span></span><br><span class="line">    QueriesClass <span class="type">uint16</span> <span class="comment">// 查询类 1:IN 2:CS 3:CH 4:HS 通常为1表示为TCP/IP互联网地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义响应数据的结构体</span></span><br><span class="line"><span class="keyword">type</span> dnsAnswer <span class="keyword">struct</span> &#123;</span><br><span class="line">    AnswerName       <span class="type">uint16</span> <span class="comment">// 同dnsQuestion.QueriesName 要查询的域名</span></span><br><span class="line">    AnswerType       <span class="type">uint16</span> <span class="comment">// 应答记录的类型 1:A 2:NS 5:CNAME 6:SOA 12:PTR 15:MX 16:TXT 28:AAAA</span></span><br><span class="line">    AnswerClass      <span class="type">uint16</span> <span class="comment">// 同dnsQuestion.QueriesClass</span></span><br><span class="line">    AnswerTTL        <span class="type">uint32</span> <span class="comment">// 32位生存时间(有效期)单位是秒</span></span><br><span class="line">    AnswerDataLength <span class="type">uint16</span> <span class="comment">// 16位无符号整数，表示应答资源记录中数据的长度</span></span><br><span class="line">    AnswerCNAME      <span class="type">string</span> <span class="string">`net:&quot;domain-name&quot;`</span> <span class="comment">// 别名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>写入DNS头部数据 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写入DNS协议头部数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dDNSData *DNSData)</span></span> WriteHeader() []<span class="type">byte</span> &#123;</span><br><span class="line">    <span class="comment">// DNS协议定义Header为12个字节的固定长度</span></span><br><span class="line">    bs := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">12</span>)</span><br><span class="line">    binary.BigEndian.PutUint16(bs[<span class="number">0</span>:<span class="number">2</span>], dDNSData.TransactionId)</span><br><span class="line">    binary.BigEndian.PutUint16(bs[<span class="number">2</span>:<span class="number">4</span>], dDNSData.Flags)</span><br><span class="line">    binary.BigEndian.PutUint16(bs[<span class="number">4</span>:<span class="number">6</span>], <span class="type">uint16</span>(<span class="built_in">len</span>(dDNSData.Queries))) <span class="comment">// Queries的数组长度值为Questions</span></span><br><span class="line">    binary.BigEndian.PutUint16(bs[<span class="number">6</span>:<span class="number">8</span>], <span class="type">uint16</span>(<span class="built_in">len</span>(dDNSData.Answers))) <span class="comment">// Answers的数组长度值为AnswerRRs</span></span><br><span class="line">    binary.BigEndian.PutUint16(bs[<span class="number">8</span>:<span class="number">10</span>], dDNSData.AuthorityRRs)</span><br><span class="line">    binary.BigEndian.PutUint16(bs[<span class="number">10</span>:<span class="number">12</span>], dDNSData.AdditionalRRs)</span><br><span class="line">    <span class="comment">// 填充Question数据，要将域名进行转换。用.分割域名字符串</span></span><br><span class="line">    ds := strings.Split(dDNSData.Queries[<span class="number">0</span>].QueriesName, <span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="comment">// 循环遍历域名的每一部分，将其长度和内容写入到字节切片中。例如：list.eber.vip，写入的内容为4list4eber3vip0 末尾用0来表示结束。</span></span><br><span class="line">    <span class="keyword">for</span> _, d := <span class="keyword">range</span> ds &#123;</span><br><span class="line">        bs = <span class="built_in">append</span>(bs, <span class="type">byte</span>(<span class="built_in">len</span>(d)))</span><br><span class="line">        bs = <span class="built_in">append</span>(bs, []<span class="type">byte</span>(d)...)</span><br><span class="line">    &#125;</span><br><span class="line">    bs = <span class="built_in">append</span>(bs, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 添加查询类型和分类</span></span><br><span class="line">    temp := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">2</span>)</span><br><span class="line">    binary.BigEndian.PutUint16(temp, dDNSData.Queries[<span class="number">0</span>].QueriesType)</span><br><span class="line">    bs = <span class="built_in">append</span>(bs, temp...)</span><br><span class="line">    binary.BigEndian.PutUint16(temp, dDNSData.Queries[<span class="number">0</span>].QueriesClass)</span><br><span class="line">    bs = <span class="built_in">append</span>(bs, temp...)</span><br><span class="line">    <span class="keyword">return</span> bs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>测试发送请求 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试发送DNS请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDNSDemo1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    dnsServer := <span class="string">&quot;114.114.114.114:53&quot;</span></span><br><span class="line">    dnsProtocol := <span class="string">&quot;udp&quot;</span></span><br><span class="line">    dnsType := <span class="type">uint16</span>(<span class="number">1</span>)</span><br><span class="line">    dnsClass := <span class="type">uint16</span>(<span class="number">1</span>)</span><br><span class="line">    udpAddr, err := net.ResolveUDPAddr(dnsProtocol, dnsServer)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    conn, err := net.DialUDP(dnsProtocol, <span class="literal">nil</span>, udpAddr)</span><br><span class="line"></span><br><span class="line">    question := dnsQuestion&#123;<span class="string">&quot;dns.eber.vip&quot;</span>, dnsType, dnsClass&#125;</span><br><span class="line">    out := DNSData&#123;&#125;</span><br><span class="line">    out.TransactionId = <span class="number">2015</span> <span class="comment">// 这里随便给个值 0~65536</span></span><br><span class="line">    out.SetFlag(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    out.Queries = <span class="built_in">append</span>(out.Queries, question)</span><br><span class="line">    header := out.WriteHeader()</span><br><span class="line">    fmt.Println(header)</span><br><span class="line">    _, err = conn.Write(header)</span><br><span class="line">    <span class="keyword">var</span> buf []<span class="type">byte</span></span><br><span class="line">    buf = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">512</span>)</span><br><span class="line">    n, err := conn.Read(buf[<span class="number">0</span>:])</span><br><span class="line">    fmt.Println(buf[<span class="number">0</span>:n])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>不出意外的话执行后Wireshark会捕获到该请求的DNS数据包。OK，这样我们就完成了一个简单的DNS请求。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
            <tag> 反射放大攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自建tailscale custom derp记录</title>
      <link href="/post/2023/05/06/65448/"/>
      <url>/post/2023/05/06/65448/</url>
      
        <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>服务器</p><p> 一个有公网IP的服务器，我这里使用的是腾讯云轻量应用服务器，系统是Ubuntu 20.04 LTS，单核2G，5M带宽500G流量。这个配置做derp服务基本是够用的，因为我的设备之间基本都能正常建立p2p连接所以流量方面也不会消耗太多。</p></li><li><p>域名</p><p> 一个解析到上述服务器公网IP的域名，这个域名是用来访问derp中转服务的。</p></li></ol><h2 id="安装derper-server"><a href="#安装derper-server" class="headerlink" title="安装derper server"></a>安装derper server</h2><h3 id="首先要安装golang-如果系统已经有go环境则跳过"><a href="#首先要安装golang-如果系统已经有go环境则跳过" class="headerlink" title="首先要安装golang 如果系统已经有go环境则跳过"></a>首先要安装golang 如果系统已经有go环境则跳过</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接下载go官网最新的包</span></span><br><span class="line">wget https://go.dev/dl/go1.20.4.linux-amd64.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压到/usr/local目录下</span></span><br><span class="line">tar -C /usr/local -xzf go1.20.4.linux-amd64.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置环境变量</span></span><br><span class="line">export PATH=$PATH:/usr/local/go/bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否安装成功</span></span><br><span class="line">go version</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回显 go version go1.20.4 linux/amd64 则表示安装成功</span></span><br></pre></td></tr></table></figure><h3 id="安装derper-server-1"><a href="#安装derper-server-1" class="headerlink" title="安装derper server"></a>安装derper server</h3><p>这里要注意它会默认安装到 <code>$HOME/go/bin</code> 目录下，比如我的就是在 <code>/root/go/bin</code> 目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line">go install tailscale.com/cmd/derper@main</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加入到PATH</span></span><br><span class="line">export PATH=$PATH:/root/go/bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证一下</span></span><br><span class="line">derper -h</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回显帮助信息则表示安装成功</span></span><br></pre></td></tr></table></figure><h2 id="使用derper-server"><a href="#使用derper-server" class="headerlink" title="使用derper server"></a>使用derper server</h2><h3 id="简单点可以直接运行"><a href="#简单点可以直接运行" class="headerlink" title="简单点可以直接运行"></a>简单点可以直接运行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-a 设置端口(如果不用https则使用非443端口且不设置-certmode manual)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-hostname 指定域名</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">stun端口不建议修改</span></span><br><span class="line">derper -a :8080 -hostname derper.eber.vip</span><br></pre></td></tr></table></figure><h3 id="搞复杂点可以使用systemd管理或者用pm2等工具管理"><a href="#搞复杂点可以使用systemd管理或者用pm2等工具管理" class="headerlink" title="搞复杂点可以使用systemd管理或者用pm2等工具管理"></a>搞复杂点可以使用systemd管理或者用pm2等工具管理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建derper.service文件</span></span><br><span class="line">vim /etc/systemd/system/derper.service</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写入以下内容</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=derper service</span><br><span class="line">After=network.target</span><br><span class="line">StartLimitIntervalSec=0</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=1</span><br><span class="line">User=root</span><br><span class="line">ExecStart=/root/go/bin/derper -a :8080 -hostname derper.eber.vip</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h2 id="配置tailscale或headscale使用自建derp"><a href="#配置tailscale或headscale使用自建derp" class="headerlink" title="配置tailscale或headscale使用自建derp"></a>配置tailscale或headscale使用自建derp</h2><p>我之前是使用的headscale自建的服务端，但是用了一段时间有个版本升级不兼容旧的数据库结构，所以直接就换回tailscale了。官方免费的tailscale套餐已经足够我使用了，感觉没必要再用headscale了。</p><h3 id="先说官方版tailscale的配置"><a href="#先说官方版tailscale的配置" class="headerlink" title="先说官方版tailscale的配置"></a>先说官方版tailscale的配置</h3><p>登录到tailscal控制台后，点击Access Controls，直接在配置文件末尾大括号前一行加入如下配置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;derpMap&quot;:</span> &#123;</span><br><span class="line">    <span class="string">//</span> <span class="string">这个是设置不使用官方默认的derp节点</span></span><br><span class="line"><span class="attr">&quot;OmitDefaultRegions&quot;:</span> <span class="literal">true</span>,</span><br><span class="line"><span class="attr">&quot;Regions&quot;:</span> &#123;</span><br><span class="line"><span class="attr">&quot;900&quot;:</span> &#123;</span><br><span class="line"><span class="attr">&quot;RegionID&quot;:</span> <span class="number">900</span>,</span><br><span class="line"><span class="attr">&quot;RegionCode&quot;:</span> <span class="string">&quot;CN&quot;</span>,</span><br><span class="line"><span class="attr">&quot;RegionName&quot;:</span> <span class="string">&quot;Shanghai&quot;</span>,</span><br><span class="line"><span class="attr">&quot;Nodes&quot;:</span> [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;Name&quot;:</span> <span class="string">&quot;腾讯云上海&quot;</span>,</span><br><span class="line"><span class="attr">&quot;RegionID&quot;:</span> <span class="number">900</span>,</span><br><span class="line"><span class="attr">&quot;HostName&quot;:</span> <span class="string">&quot;derper.eber.vip&quot;</span>,</span><br><span class="line"><span class="attr">&quot;DERPPort&quot;:</span> <span class="number">8080</span>,</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;<span class="string">,</span></span><br></pre></td></tr></table></figure><p>配置完成后点击Save保存，然后在客户端设备上执行 tailscale netcheck，会有类似如下输出。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@oc-au1:~# tailscale netcheck</span><br><span class="line"></span><br><span class="line">Report:</span><br><span class="line">        * UDP: true</span><br><span class="line">        * IPv4: yes, 152.67.99.59:59810</span><br><span class="line">        * IPv6: no, but OS has support</span><br><span class="line">        * MappingVariesByDestIP: false</span><br><span class="line">        * HairPinning: true</span><br><span class="line">        * PortMapping: </span><br><span class="line">        * Nearest DERP: Shanghai</span><br><span class="line">        * DERP latency:</span><br><span class="line">                -  CN: 295ms   (Shanghai)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示你配置的节点RegionCode和RegionName则为成功，然后可以两个客户端互ping进一步确认是否能正常中转流量。</span></span><br></pre></td></tr></table></figure><h3 id="再说headscale的配置"><a href="#再说headscale的配置" class="headerlink" title="再说headscale的配置"></a>再说headscale的配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接修改 /etc/headscale/config.yaml 文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先注释掉官方的默认derp urls配置</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">urls:</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"> - https://controlplane.tailscale.com/derpmap/default</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后加入自己的derp配置</span></span><br><span class="line">  paths:</span><br><span class="line">    - /etc/headscale/derp.yaml</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建 /etc/headscale/derp.yaml 文件</span></span><br><span class="line">vim /etc/headscale/derp.yaml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写入以下内容</span></span><br><span class="line">regions:</span><br><span class="line">    900:</span><br><span class="line">      regionid: 900</span><br><span class="line">      regioncode: CN</span><br><span class="line">      regionname: Shanghai</span><br><span class="line">      nodes:</span><br><span class="line">        - name: 腾讯云上海</span><br><span class="line">          regionid: 900</span><br><span class="line">          hostname: derper.eber.vip</span><br><span class="line">          derpport: 8080</span><br><span class="line">          stunport: 3478</span><br><span class="line">          stunonly: false </span><br></pre></td></tr></table></figure><p>OK！结束🔚，还想再说一句 官方版的用着确实省心。个人用途的话免费版基本足够了不建议用headscale 太折腾了！</p>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tailscale </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据传输小笔记</title>
      <link href="/post/2023/04/23/2754/"/>
      <url>/post/2023/04/23/2754/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="d939845a74279f3e6cedc853bb99628e7c1485149b42cbe0dfd6dfe10f8e7591">d7d1313d74f5f9937c4c6f57d41c156905ce4011da20712fd7652fef2f0ee9c78ae2463f9f5794aea31097eb57233e41f5b9ea62aa2bf6300e4f14c8dbaeaee87ea9e58b18f0b42d1afc81519496cb9f07632c5fb3ba34107f22175c9f431b89ce9bd9e052ae9aad9999862bb17c106a5ee93c7f4f5db475c20bd3110c0508848e39b6105e9728e5683725ecb91c958eb915908452558100d61f2a7acbaae17d9495456a935c339f8af74184581bd0a17b5cf2d8b3b9a90ce895d1555814024d664d9d98cd3cf08f9fb14d3d559c536df88012dbd488b8bce315781ffc374413231f646554177ef8f067bf2d825f186c339a97d21eba3531c36f148a627f1cd34af72ee500e79875976c38403f1dfd90a170f690e844c58828932dd21712e347aaa847586c72e7bc924a43341d5beb89f68877dfbae593fc311cf8767ab7e779feff760bd0608f1534fafdf4aadba6e734ef09009157c45dcdb1b1e67ac9d3443ce7c6c5c06ba5933dca424512af1fa00c65a77d3acc8eac9ae6399ef8e1602b4f478753ec8316d8f22ab7bd7b51318622239c605b95082388c0fee1373d33ab9347dacfb929997c31417cdc3780e183ff7c47f09eb845a9a55ec68e647ec13c8104e18ec058a863c50ef8bab9796ad7f4b0ebf59c2ac4b5940a42ecea2eb2a9edbc22bb4a0e3084e96e536a5f1b934ade29764e9efe3ce93f44fe6eaa8aa949512058cd89baa7c2e07a464299f27a69099349f998e1ca83a62f72871a68c47c7cf928798bd531a782df7953bd6bab54eba93a76a15c45fc3661da90cac3ac4804b8f5fc6f7758a3dc1e05373d04d1d38c989530d6d3917876a42369603cfd36ee8727e27884c9ab9b912f7eb36f41065ec01cd9eeddd54a9f9457490c1f26911ede52d88ef42898d5bc1c03682993d283e3b0da08c8783a98886da79ed6de70b03a3307c97423eb68c76c02ea282aeeee48e4ad361cb35b18790b8359272ef48e0a5bd93bb881ff511cd575829d0112443dc0b5b17bf6f3bdbab140a65b49f233d2f7bcdb67efdb5b77102f0e44a14700b4bac7e7dc17c305a67c89509b3347032af28930be612486528f9676507f8cac9cd1c2e0ea64a61397a88e5cb3fb5cfdaf7c8151343d00f256dca5bca803d3df6a8d834bb4cefdcb07aa40297ac1acb5bae7b9197ddaf3531ba802a94115648e3de685b16aadcc1e50493d12562f5815e305daf459f410c38532c0fe618821094f10b4486ab25366479a55437653d10e97aa31ce1390e97b2e71eeb0b5556803beff5fde7bdc6cf0686e9a4e32d1fe0d00b5465d562fc11b65c6c2c743f6c73da945e248516e994f0d70fa11b3a5208e9c883dbd0cd74c49e610c0028af5f7326f8e5c534067276c8d675c115308445e7192865dece143acf397010b350f5bf43c1362e5ed17ecb4b700abf3d74af47dee3868be58e15741bb37ec57003db9cf97d21f41c3e48de9a67c9e803a7c360c40e0ed65699d7ac3841f5d1732531a4b0d0fea3da6285a261192d59bcd668bccebdb8b40171167d6739b2411380d56df8b6c3e51161c01bad19c62c58d944c0d32f748726b64bd93a9f50a5c6061cf75c250808f9633fb64b85fa1c832224bf4933eab4e99ffd3d6810da24469d2180a20e79872591d2d0c17d81bad0719ae045298e9e1abeba3fe4c85ac272bdf8febb1a5af62e3979f8e2a6a8129d2e44cd7d6c1577761e69a0d30f0dd2ef64df27640727a40b453ed00221bde08766ca438f82f32d72ce329fddc45a482ea2952695cac460e06a864b360ccd52f3a09b535a8ee8da8a0a4d4be0ca391e9cd80d2a3001c3b3ad5b050b05eb3367fa44359ea9783a046f557d39f0580a88867a2153870f7d56ed495cc6dcd5b5b345d5248be54e63e304d602e450ec328855f265d4020a500ba3f1e1b740114f3036bc2c2f4a634c81cb26d8caa3434516f8854ccebe2aa21bedcadcc7a6ca64003be84fb402da8c1f8aa02a7318acf52aa1a324546ce391018f0c06e2acd640e451ee0b3b93fd6625167020dc6b103c460094813fd5af5815e90bfc6e23fdf2d5df4320dd06c1b9b0e5ca87a0e2ef4bb8c03bab7f54e9e7bff82745875b95692792b2b551f55571a85f18725bea9d5dc4e31da7145c478a7c587931f72ee8420c04675311714811b47c1fcc9077c055357db7acd75f0b07106481f99a43f5ecdd77c8989363e66ce36d88728a92c0136e41812b4fa884525a55be50fc04b8adf95531be87bafc8ce8fe1138797a7f362fa475367a8d16a592700f2e9fb4502566e809b7dbb5b5a04fa1eb2723eca93ca3ccaa0546698d310325663b6843cbff21a179335590db56f4d3a4419e61d175c3800111719c2685ae8d83f74742b067d48244e15bb912c902004b24aec4c69c8fd9d7dd13109e6e8540b53ee66648b72b84d006a7a0c4301fbd21a1522bcac53be23caa04a7565905793d90f52723106d778597bf9621a4a63e0a1fbcc905abc3627de3723ffd9a6f5559b6e3f8d4bc54b9bc1697897a18f093a0b5cb1af21bbfa7c1ff626fc9e4f9ad173bb0a9ec474dbcef50f6a0f039e656d556c08d883b4ace12cbc1b65161ca5dc1a3286b26f4445f77bc1be90ba25a1246fb5672056be1c5c2e5caae336ea9663a8a48b5edf8b59b60adcf289eded3e91b6dae959ef39e88d8be700f2d25f80b050dee056ebf840ea99136bfd9e5fff32c6675808c3a0f93eb6545b70387eb3e8a18cf8c5b3445758bc2cde1580374d1c5f147aebeb116aa2d09b8295f2f0e6f92125dd0e3982071682e42d190f3f5cbd1a181652c2696e43fd2dad27b55692c1942ce27d92bf84f671852bc8b86626a6e4b65d4dd57980bcefe2649def7e76cb2aada24e2c81114dca81bc22da4132a37c474b7dd8f55f051943e7fd6ca76780714e98c9325c3c59144ce496e32ab5dc7b4545d2d45f92edc8b84c5899a12ecbaa6fe97f0678dbca486cb32b2cf1ee3c0d1f129cb213de1133cd78e6ce7398fdd0eb8d37fcc47a9473c116626697e60b20cee7bca551c7466b93e6317d7f50f0e0da8c76d39a7779ffdd1a3237a11094419092ba8153df054553c576b4ef82903de4f26325a73055696b7bb9cb371a9111dce240d799e8d35d67ca906b974397cacff3ad95ebcf849ac26534327b690a739b3ab2f2583fe205d23bbab035144e8019e7fc2a0bcd256f8183bdfc563976a0774a793fc72dd76c14ed428feb6ec9b1c36c3c2be0bfa231fdc9b1d1b9159174a32e14ed4e0fab4f682460a905cf24c93af237a1ba7185bddf917b9a4e6db632e3a4ff0e6b3c3e6bb97be0ce5155f2ddaf2d8bce064f8afccee737b36defec7f4bb81633c9e086daaa2ac1a6504203f904249808d43b2e1fab5b6e0efc94c9a3f71623d6b88e0477a80360a2180bb165dfd40cdf6ac7279fe75407cada2509c85983c8879ec6f3ececf391bf37b516adf06e4a34ecdc67b797332bf3162076d805ce556e4cb59d20ab181608e1652fcb02a72a152ba42e1bcf1b6d3ddc93c68799d894b40b50c486aa8a454b962f58fc3fb9a965258ab0adc12fc59523ebf11399124e11f49d76c1b309b48cd4b539e4094a45e62f1169659a36fb671fe4d53408c0cbfdee4b6fe9ef4554c4a5b268b6ac4425e37ac80bf6de8519b00717329233a0eb59f835bc203e6b3eb42cf64b6d702dd232e4c9dfec333481feb8dd247a40aa6b0a06ff6b6631ec5880512c9544754a705f7ea98d4fdc981bcb3b8fd89ef6b4b91d813fb6c9fce3e4659abfaf0c1884b9a8e737b6e8c3a29a38c552f7e517d5be1750f775976ccc90400e4799b80ec126f8f1651b65a64b7be35a96241939658c3b4e935696aaed1f74cab267a9b41629bcba0b8da9115683194cd8ec0e66841fb69180fe7df824e49ffc95522ed31deffbc564c51c4cba6a1ca666ceee1627b950be6acd2f77661e49ef1862e1904390cf718048a9e0ec9d1c303ab766418eb335c206c9ef5cea76ff1307525533ba09794b504f5e404bcf3dcb75488bb8bb80c04e06338ffa8cd3a77bc2e6f97ec7c2b9a421b9a9461087ef110363fd7518d5ace38d45f72b7807f953ec867fe44a80051e618519f91d44877cb292f122aec4f721784107568577a829741f1a96a99bb70c17a1d951d279d5aa8b5576252a5001234bf96b9ac7ac3f566dfc448c8422f6d6457f186265680b0d448cf0821a1196ac0a0a9c878e5009fc41b8f3e2005802a101e3a2f409c8ec36745bf364060bdfd6dd1980992b441170ce77c9bc1e30c742d0acda22a03d3ff580a996f1e7d616d0246b3d19293d84a5d76b3d957bf7db3a38c1b3345409918c48f069b06b1f3ac35862a786d90968ea1e6980d61c4fe4d675057923d6dc93669193264bfc93a88a3fb97623208b89fe9479705e90f52c3430614360189fa3c54c65dcd35168cfd2a3dd97160453a43b9654d577c56aea408bc74eb306d41739b1dd2958ac95b9156049bc86e28bdc323e917bf1ba3288e6dff290245e7b9342d95d01e8851cf9270b797fd59becbf8fe3688b6273130323901aec731effcb6346a174acd61868cb641622bd5790fdf86a6c04d72e88b42b98d43a629bf90ec915a6f0b8871f7077eef72af7d8e0a85cd42c1e4fb5f7ca2fc8bff334a5ebc959b32c1a0948e7868236f4a074601b7749be4a78961e7c101527a662d0</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 串口通讯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电脑和手机是如何知道自己连上网的</title>
      <link href="/post/2023/04/22/55144/"/>
      <url>/post/2023/04/22/55144/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>玩安卓经常刷机的小伙伴可能会发现有些国外的包比如LineageOS等，刷机后会发现Wi-Fi图标有无网络的标识或手机提醒该Wi-Fi无法联网。这是如何产生的呢？</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>因为电脑或手机等网络终端会有一个探测网络连接的机制，当网络连接不可用时及时提示用户。这就是<mark class="hl-label pink">204</mark> 机制。那么这个机制是如何实现的呢？</p><h2 id="机制分析"><a href="#机制分析" class="headerlink" title="机制分析"></a>机制分析</h2><ul><li><p>安卓手机会请求类似这样的一个地址 <code>http://www.google.com/generate_204</code> ，如果返回的状态码是204则说明网络连接正常，否则说明网络连接不正常。这个地址是Google提供的，所以国外的包也会使用这个地址来探测网络连接。</p></li><li><p>Mac电脑会请求类似这样的一个地址 <code>http://captive.apple.com/hotspot-detect.html</code> ，如果响应文本 <code>Success</code> 则说明网络连接正常，否则说明网络连接不正常。这个地址是Apple提供的，所以苹果电脑也会使用这个地址来探测网络连接。</p></li><li><p>Windows电脑会请求类似这样的一个地址 <code>http://www.msftconnecttest.com/connecttest.txt</code> ，如果响应文本 <code>Microsoft Connect Test</code> 则说明网络连接正常，否则说明网络连接不正常。这个地址是微软提供的，所以Windows电脑也会使用这个地址来探测网络连接。</p></li></ul><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>安卓手机可以根据实际网络环境修改如下地址去解决这个问题。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.gstatic.com/generate_204</span><br><span class="line">http://www.google-analytics.com/generate_204</span><br><span class="line">http://www.google.com/generate_204</span><br><span class="line">http://connectivitycheck.gstatic.com/generate_204</span><br><span class="line">http://connect.rom.miui.com/generate_204</span><br><span class="line">http://connectivitycheck.platform.hicloud.com/generate_204</span><br><span class="line">http://wifi.vivo.com.cn/generate_204</span><br></pre></td></tr></table></figure><p>Windows电脑可以根据实际网络环境修改如下地址去解决这个问题。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.msftconnecttest.com/connecttest.txt</span><br><span class="line">http://www.msftncsi.com/ncsi.txt</span><br><span class="line">http://detectportal.firefox.com/success.txt</span><br><span class="line">http://network-test.debian.org/nm</span><br></pre></td></tr></table></figure><p>Mac电脑不用折腾，从来没见过Mac有这种问题。苹果还是牛逼哈，用户体验做到极致！</p><p>windows推荐GitHub上一个 <a href="https://github.com/crazy-max/WindowsSpyBlocker">好用的工具</a> 可以快速修改，不用再自己一个一个注册表项去改了。</p>]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang的fmt占位符笔记</title>
      <link href="/post/2023/04/16/53040/"/>
      <url>/post/2023/04/16/53040/</url>
      
        <content type="html"><![CDATA[<h1 id="GitHub-Copilot插件"><a href="#GitHub-Copilot插件" class="headerlink" title="GitHub Copilot插件"></a>GitHub Copilot插件</h1><p>正文开始前，先介绍一个小插件 - Copilot，是GitHub推出的一个AI代码补全插件。<a href="https://copilot.github.com/">官网链接</a>，<a href="https://copilot.github.com/docs/">官方文档</a>，<a href="https://copilot.github.com/blog/">官方博客</a>，<a href="https://twitter.com/copilot">官方Twitter</a>。</p><p>目前GitHub学生认证账号可免费使用，<a href="https://education.github.com/pack">GitHub学生认证</a>，<a href="https://education.github.com/discount_requests/new">GitHub学生认证申请</a>。</p><p>申请完许可之后直接到JetBrains插件市场搜索Copilot安装即可，<a href="https://plugins.jetbrains.com/plugin/14896-copilot">JetBrains插件市场</a>。安装完之后会连接GitHub进行认证，认证成功后就可以使用了。</p><p>用了大约有两周，感觉还不错，可以帮助我们快速生成代码，但是生成的代码不一定是最优的，需要我们自己再优化一下。目前Copilot只支持Python、Java、JavaScript、TypeScript、Go、Ruby、PHP、C#、C++、Kotlin、Scala、Dart、Swift、Rust、Julia、Elixir、Clojure、Haskell、OCaml、F#、Elm、Erlang、Prolog、Perl、Lua等</p><p>是的上面几行大部分内容也是生成的。。。我只写了个开头。本篇文章大概只有20%的内容是我敲出来的。因为我的博文一直在GoLand上写，所以以后可能会有更多AI生成的内容。</p><h1 id="Golang的fmt占位符笔记"><a href="#Golang的fmt占位符笔记" class="headerlink" title="Golang的fmt占位符笔记"></a>Golang的fmt占位符笔记</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = Dog&#123;</span><br><span class="line">    Name: <span class="string">&quot;小砾&quot;</span>,</span><br><span class="line">    Age:  <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><mark class="hl-label pink">本笔记后面部分为Copilot生成的代码，下图Gif是部分生成示例。仅供参考！</mark> <p><img src="https://up.eber.vip/Think-Me/img/main/upload/Kapture%202023-04-17%20at%2012.44.48.gif"></p><p>猜测可能是根据官方文档加上我上面的结构体的定义而生成的，<a href="https://golang.org/pkg/fmt/">官方文档链接</a></p><h2 id="普通占位符"><a href="#普通占位符" class="headerlink" title="普通占位符"></a>普通占位符</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// %v 默认格式</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v&quot;</span>, dog) <span class="comment">// &#123;小砾 1&#125;</span></span><br><span class="line"><span class="comment">// %+v 打印结构体时，会添加字段名</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v&quot;</span>, dog) <span class="comment">// &#123;Name:小砾 Age:1&#125;</span></span><br><span class="line"><span class="comment">// %#v 值的Go语法表示</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v&quot;</span>, dog) <span class="comment">// main.Dog&#123;Name:&quot;小砾&quot;, Age:1&#125;</span></span><br><span class="line"><span class="comment">// %T 打印值的类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T&quot;</span>, dog) <span class="comment">// main.Dog</span></span><br><span class="line"><span class="comment">// %% 打印%</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%%&quot;</span>) <span class="comment">// %</span></span><br></pre></td></tr></table></figure><h2 id="布尔占位符"><a href="#布尔占位符" class="headerlink" title="布尔占位符"></a>布尔占位符</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// %t true or false</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%t&quot;</span>, <span class="literal">true</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="整数占位符"><a href="#整数占位符" class="headerlink" title="整数占位符"></a>整数占位符</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// %b 二进制</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%b&quot;</span>, <span class="number">10</span>) <span class="comment">// 1010</span></span><br><span class="line"><span class="comment">// %c 对应的Unicode码值</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%c&quot;</span>, <span class="number">65</span>) <span class="comment">// A</span></span><br><span class="line"><span class="comment">// %d 十进制</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d&quot;</span>, <span class="number">10</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="comment">// %o 八进制</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%o&quot;</span>, <span class="number">10</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="comment">// %q 单引号围绕的字符字面值，由Go语法安全地转义</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q&quot;</span>, <span class="number">65</span>) <span class="comment">// &#x27;A&#x27;</span></span><br><span class="line"><span class="comment">// %x 十六进制，字母形式为小写 a-f</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%x&quot;</span>, <span class="number">10</span>) <span class="comment">// a</span></span><br><span class="line"><span class="comment">// %X 十六进制，字母形式为大写 A-F</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%X&quot;</span>, <span class="number">10</span>) <span class="comment">// A</span></span><br><span class="line"><span class="comment">// %U Unicode格式：U+1234，等同于 &quot;U+%04X&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%U&quot;</span>, <span class="number">65</span>) <span class="comment">// U+0041</span></span><br></pre></td></tr></table></figure><h2 id="浮点数占位符"><a href="#浮点数占位符" class="headerlink" title="浮点数占位符"></a>浮点数占位符</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// %b 无小数部分、二进制指数的科学计数法，如 -123456p-78</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%b&quot;</span>, <span class="number">10.1</span>) <span class="comment">// 1.0001100110011001100110011001100110011001100110011001101p+3</span></span><br><span class="line"><span class="comment">// %e 科学计数法，如 -1234.456e+78</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%e&quot;</span>, <span class="number">10.1</span>) <span class="comment">// 1.010000e+01</span></span><br><span class="line"><span class="comment">// %E 科学计数法，如 -1234.456E+78</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%E&quot;</span>, <span class="number">10.1</span>) <span class="comment">// 1.010000E+01</span></span><br><span class="line"><span class="comment">// %f 有小数点而无指数，如 123.456</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%f&quot;</span>, <span class="number">10.1</span>) <span class="comment">// 10.100000</span></span><br><span class="line"><span class="comment">// %F %f的同义词</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%F&quot;</span>, <span class="number">10.1</span>) <span class="comment">// 10.100000</span></span><br><span class="line"><span class="comment">// %g 根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%g&quot;</span>, <span class="number">10.1</span>) <span class="comment">// 10.1</span></span><br><span class="line"><span class="comment">// %G 根据情况选择 %E 或 %F 以产生更紧凑的（无末尾的0）输出</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%G&quot;</span>, <span class="number">10.1</span>) <span class="comment">// 10.1</span></span><br></pre></td></tr></table></figure><h2 id="字符串占位符"><a href="#字符串占位符" class="headerlink" title="字符串占位符"></a>字符串占位符</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// %s 直接输出字符串或者[]byte</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;hello&quot;</span>) <span class="comment">// hello</span></span><br><span class="line"><span class="comment">// %q 带双引号的字符串，由Go语法安全地转义</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q&quot;</span>, <span class="string">&quot;hello&quot;</span>) <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"><span class="comment">// %x 每个字节用两字符十六进制数表示（使用a-f）</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%x&quot;</span>, <span class="string">&quot;hello&quot;</span>) <span class="comment">// 68656c6c6f</span></span><br><span class="line"><span class="comment">// %X 每个字节用两字符十六进制数表示（使用A-F）</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%X&quot;</span>, <span class="string">&quot;hello&quot;</span>) <span class="comment">// 68656C6C6F</span></span><br></pre></td></tr></table></figure><h2 id="指针占位符"><a href="#指针占位符" class="headerlink" title="指针占位符"></a>指针占位符</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// %p 十六进制表示，前缀 0x</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%p&quot;</span>, &amp;dog) <span class="comment">// 0xc0000b4000</span></span><br></pre></td></tr></table></figure><h2 id="宽度标识符"><a href="#宽度标识符" class="headerlink" title="宽度标识符"></a>宽度标识符</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// %n 宽度为n的整数，右对齐</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%10d&quot;</span>, <span class="number">10</span>) <span class="comment">//         10</span></span><br><span class="line"><span class="comment">// %-n 宽度为n的整数，左对齐</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%-10d&quot;</span>, <span class="number">10</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="comment">// %0n 宽度为n的整数，右对齐，左边填充0</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%010d&quot;</span>, <span class="number">10</span>) <span class="comment">// 0000000010</span></span><br></pre></td></tr></table></figure><h2 id="精度标识符"><a href="#精度标识符" class="headerlink" title="精度标识符"></a>精度标识符</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// %.nf 格式化浮点数，n表示小数点后的位数</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%.2f&quot;</span>, <span class="number">10.1</span>) <span class="comment">// 10.10</span></span><br><span class="line"><span class="comment">// %e %E %f %F %g %G 的精度表示</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%.2e&quot;</span>, <span class="number">10.1</span>) <span class="comment">// 1.01e+01</span></span><br></pre></td></tr></table></figure><h2 id="标志标识符"><a href="#标志标识符" class="headerlink" title="标志标识符"></a>标志标识符</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// %+d 带符号的整数</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%+d&quot;</span>, <span class="number">10</span>) <span class="comment">// +10</span></span><br><span class="line"><span class="comment">// % d 带空格的整数</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;% d&quot;</span>, <span class="number">10</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="comment">// %#x %#X 带0x/0X的十六进制</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#x&quot;</span>, <span class="number">10</span>) <span class="comment">// 0xa</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#X&quot;</span>, <span class="number">10</span>) <span class="comment">// 0XA</span></span><br><span class="line"><span class="comment">// %T 打印值的类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T&quot;</span>, <span class="number">10</span>) <span class="comment">// int</span></span><br><span class="line"><span class="comment">// %v 默认格式</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v&quot;</span>, <span class="number">10</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="comment">// %b %d %o %x %X 的简写</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%b&quot;</span>, <span class="number">10</span>) <span class="comment">// 1010</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d&quot;</span>, <span class="number">10</span>) <span class="comment">// 10</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%o&quot;</span>, <span class="number">10</span>) <span class="comment">// 12</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%x&quot;</span>, <span class="number">10</span>) <span class="comment">// a</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%X&quot;</span>, <span class="number">10</span>) <span class="comment">// A</span></span><br><span class="line"><span class="comment">// %U Unicode格式：U+1234，等同于 &quot;U+%04X&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%U&quot;</span>, <span class="number">65</span>) <span class="comment">// U+0041</span></span><br><span class="line"><span class="comment">// %c 对应的Unicode码值</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%c&quot;</span>, <span class="number">65</span>) <span class="comment">// A</span></span><br><span class="line"><span class="comment">// %q 单引号围绕的字符字面值，由Go语法安全地转义</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q&quot;</span>, <span class="number">65</span>) <span class="comment">// &#x27;A&#x27;</span></span><br><span class="line"><span class="comment">// %x %X 的简写</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%x&quot;</span>, <span class="string">&quot;hello&quot;</span>) <span class="comment">// 68656c6c6f</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%X&quot;</span>, <span class="string">&quot;hello&quot;</span>) <span class="comment">// 68656C6C6F</span></span><br><span class="line"><span class="comment">// %s %q %x %X 的简写</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;hello&quot;</span>) <span class="comment">// hello</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q&quot;</span>, <span class="string">&quot;hello&quot;</span>) <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%x&quot;</span>, <span class="string">&quot;hello&quot;</span>) <span class="comment">// 68656c6c6f</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%X&quot;</span>, <span class="string">&quot;hello&quot;</span>) <span class="comment">// 68656C6C6F</span></span><br><span class="line"><span class="comment">// %p 十六进制表示，前缀 0x</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%p&quot;</span>, &amp;dog) <span class="comment">// 0xc0000b4000</span></span><br><span class="line"><span class="comment">// %e %E %f %F %g %G 的简写</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%e&quot;</span>, <span class="number">10.1</span>) <span class="comment">// 1.010000e+01</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%E&quot;</span>, <span class="number">10.1</span>) <span class="comment">// 1.010000E+01</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%f&quot;</span>, <span class="number">10.1</span>) <span class="comment">// 10.100000</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%F&quot;</span>, <span class="number">10.1</span>) <span class="comment">// 10.100000</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%g&quot;</span>, <span class="number">10.1</span>) <span class="comment">// 10.1</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%G&quot;</span>, <span class="number">10.1</span>) <span class="comment">// 10.1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发与测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Copilot </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Actions笔记</title>
      <link href="/post/2023/04/14/17500/"/>
      <url>/post/2023/04/14/17500/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>GitHub Actions是GitHub的持续集成服务，每个用户每月都有一定的免费额度。</p><p>GitHub Free账户每月可免费使用2000分钟，存储为每个账户终身500M。其中Linux计时为1倍率，Windows计时为2倍率，macOS计时为10倍率。简单来说就是每月纯用Linux构建可用2000分钟，纯用Windows构建可用1000分钟，纯用macOS构建可用200分钟。更多计费规则参考<a href="https://docs.github.com/zh/billing/managing-billing-for-github-actions/about-billing-for-github-actions">官方计费文档</a></p><h3 id="Actions各种术语概念"><a href="#Actions各种术语概念" class="headerlink" title="Actions各种术语概念"></a>Actions各种术语概念</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">my_first_workflow</span> <span class="comment"># 工作流的名称</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span>  <span class="comment"># 这里用推送作为触发条件</span></span><br><span class="line">    <span class="attr">branches:</span>  <span class="comment"># 可以指定分支，如果不指定则默认main分支</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">echo_and_curl_job:</span>  <span class="comment"># 第一个任务名字</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span> <span class="comment"># 这里指定用来运行任务的系统</span></span><br><span class="line">    <span class="attr">steps:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">echo</span> <span class="string">something</span> <span class="comment"># 第一个步骤</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;这是密钥：$<span class="template-variable">&#123;&#123; secrets.SK &#125;&#125;</span>&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">curl</span> <span class="string">request</span> <span class="comment"># 第二个步骤</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">curl</span> <span class="string">https://eber.vip</span></span><br><span class="line">  <span class="attr">this_is_job2:</span> <span class="comment"># 第二个任务的名字</span></span><br><span class="line">    <span class="attr">run-on:</span> <span class="string">macos-latest</span></span><br><span class="line">    <span class="attr">needs:</span> <span class="string">echo_and_curl_job</span> <span class="comment"># 这里可以指定在echo_and_curl_job任务完成之后再执行该任务</span></span><br><span class="line">    <span class="attr">steps:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">echo</span> <span class="comment"># 这是第二个任务的第一个步骤</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;1&quot;</span> <span class="comment"># 具体的执行</span></span><br></pre></td></tr></table></figure><ol><li>workflow：工作流，可以理解为每个工作流的yml配置文件就是一个workflow。</li><li>name：工作流的名称，如果不设置则为yml文件名。</li><li>on：触发条件，可以设置某个分支的推拉等动作触发、某个工作流构建状态去触发或定时触发执行。</li><li>jobs：工作流的任务，一个工作流可以有多个任务。</li><li>steps：任务下面各个执行步骤，就是在这里面指定具体干啥。</li></ol><h3 id="一些配置的备忘录"><a href="#一些配置的备忘录" class="headerlink" title="一些配置的备忘录"></a>一些配置的备忘录</h3><ul><li>触发类 <a href="https://docs.github.com/zh/actions/using-workflows/events-that-trigger-workflows">官方文档</a></li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">on:</span> </span><br><span class="line">  <span class="attr">workflow_run:</span> <span class="comment"># 设置某个指定的任务流运行完成后触发 （适合有前后依赖关系的两个任务流的场景），也可以用一个工作流多个job去实现</span></span><br><span class="line">    <span class="attr">workflows:</span> [<span class="string">my-build-deployment-workflow</span>]</span><br><span class="line">    <span class="attr">types:</span> [<span class="string">completed</span>]</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">on:</span> </span><br><span class="line">  <span class="attr">issues:</span> <span class="comment"># 场景：issues有相关操作时触发，对于开源项目维护者 很有用。</span></span><br><span class="line">    <span class="attr">types:</span> [<span class="string">opened</span>, <span class="string">edited</span>, <span class="string">milestoned</span>] <span class="comment"># 更多动作值可查看官方文档</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">on:</span> </span><br><span class="line">  <span class="attr">schedule:</span> <span class="comment"># 定时触发</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">cron:</span>  <span class="string">&#x27;30 5,17 * * *&#x27;</span> <span class="comment"># 每天5点30分和17点30分触发</span></span><br></pre></td></tr></table></figure><ul><li>环境变量类 <a href="https://docs.github.com/zh/actions/reference/environment-variables">官方文档</a></li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">env:</span> <span class="comment"># 设置整个workflow的环境变量</span></span><br><span class="line">  <span class="attr">MY_NAME:</span> <span class="string">&#x27;eber&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$&#123;&#123;</span> <span class="string">env.MY_NAME</span> <span class="string">&#125;&#125;</span> <span class="comment"># 使用环境变量</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认环境变量</span></span><br><span class="line"><span class="attr">CI:</span> <span class="literal">true</span> <span class="comment"># 始终为true</span></span><br><span class="line"><span class="attr">GITHUB_ACTION:</span> <span class="string">eber</span> <span class="comment"># 正在运行的操作的名称，或步骤的 id。 例如，对于操作，为 __repo-owner_name-of-action-repo。在当前步骤运行不带 id 的脚本时，GitHub 会删除特殊字符并使用名称 __run。 如果在同一作业中多次使用相同的脚本或操作，则名称将包含一个由序号前跟下划线组成的后缀。 例如，运行的第一个脚本的名称将为 __run，第二个脚本的名称将为 __run_2。 同样，actions/checkout 的第二次调用将为 actionscheckout2。</span></span><br><span class="line"><span class="attr">GITHUB_ACTION_PATH:</span> <span class="string">/home/runner/work/_actions/repo-owner/name-of-action-repo/v1</span> <span class="comment"># 操作所在的路径。 此属性仅在复合操作中受支持。 您可以使用此路径访问与操作位于同一存储库中的文件。</span></span><br><span class="line"><span class="attr">GITHUB_ACTION_REPOSITORY:</span> <span class="string">actions/checkout</span> <span class="comment"># 对于执行操作的步骤，这是操作的所有者和存储库名称。</span></span><br><span class="line"><span class="attr">GITHUB_ACTIONS:</span> <span class="literal">true</span> <span class="comment"># 当GitHub Actions运行工作流时，始终为true。 您可以使用此变量来区分测试是在本地运行还是通过GitHub Actions运行。</span></span><br><span class="line"><span class="attr">GITHUB_SHA:</span> <span class="string">ffac537e6cbbf934b08745a378932722df287a53</span> <span class="comment"># 触发工作流的提交 SHA。</span></span><br></pre></td></tr></table></figure><p>未完待续！！！有时间再补充</p>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub Actions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>acme.sh墙内最佳实践</title>
      <link href="/post/2023/04/13/18567/"/>
      <url>/post/2023/04/13/18567/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>受限于大陆的<mark class="hl-label pink">网络环境</mark> ，我们在使用原生acme.sh申请证书的时候，经常会遇到各种各样的问题。。。今天推荐一个国内比较好用的免费证书签发服务 - <a href="https://freessl.cn/">FreeSSL</a> 。</p><h3 id="1-安装acme-sh"><a href="#1-安装acme-sh" class="headerlink" title="1.安装acme.sh"></a>1.安装acme.sh</h3><p>这个就不用说了，基于ACME协议的最强证书自动化神器！</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装acme.sh 推荐用root用户安装，避免不必要的麻烦。</span></span><br><span class="line">curl https://get.acme.sh | sh -s email=name@domain.com <span class="comment"># 海外原脚本，如果太慢或根本连不上可以用下面的镜像版本</span></span><br><span class="line">curl https://gitcode.net/cert/cn-acme.sh/-/raw/master/install.sh?inline=<span class="literal">false</span> | sh -s email=name@domain.com <span class="comment"># 镜像地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装完毕后重新连接SSH或者执行以下命令重载环境变量</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h3 id="2-到FreeSSL-cn申请证书并部署到服务器"><a href="#2-到FreeSSL-cn申请证书并部署到服务器" class="headerlink" title="2.到FreeSSL.cn申请证书并部署到服务器"></a>2.到FreeSSL.cn申请证书并部署到服务器</h3><p>打开<a href="https://freessl.cn/">FreeSSL</a>，填写域名，选择证书品牌。推荐选择亚洲诚信多域名通配符证书，这个证书是免费三个月的并且能自动续期，而且是通配符证书，可以申请泛域名证书。<br><img src="/../img/acme/202304131337353.png" alt="202304131337353.png"><br>点击创建免费的SSL证书跳转到域名解析配置提示弹窗界面（如果没有登录会跳转到登录页面）<br><img src="/../img/acme/202304131352341.png" alt="202304131352341.png"><br>根据提示创建解析记录（这里以CloudFlare为例）<br><img src="/../img/acme/202304131353139.png" alt="202304131353139.png"><br>创建好解析记录后，回到页面点击 <mark class="hl-label blue">配置完成，立即检测</mark>  按钮，如果检测成功会跳转到部署，如果检测失败请检查解析记录是否正确。<br><img src="/../img/acme/202304131358679.png" alt="202304131358679.png"></p><p>最后复制acme.sh部署命令到服务器执行。</p><h3 id="3-安装自动化任务"><a href="#3-安装自动化任务" class="headerlink" title="3.安装自动化任务"></a>3.安装自动化任务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只要上面配置的CNAME记录不删除，后续证书就能正常自动续期。</span></span><br><span class="line">acme.sh --install-cert -d test.eber.vip --key-file /usr/local/nginx/conf/ssl/test.eber.vip.key --fullchain-file /usr/local/nginx/conf/ssl/test.eber.vip.crt --reloadcmd <span class="string">&quot;service nginx force-reload&quot;</span></span><br></pre></td></tr></table></figure><mark class="hl-label pink">注意</mark>  命令中 /usr/local/nginx/conf/ssl  替换成你自己存放证书的目录。后面的的 --reloadcmd 参数是指定证书更新后执行的命令，这里是重载Nginx配置，如有其他需求可以自行修改。<h3 id="4-配置文件示例"><a href="#4-配置文件示例" class="headerlink" title="4.配置文件示例"></a>4.配置文件示例</h3><p>这里提供一个nginx反向代理其他服务的配置文件最佳实践，可以根据实际情况修改使用。</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">  <span class="attribute">listen</span> [::]:<span class="number">80</span>;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">443</span> ssl http2;</span><br><span class="line">  <span class="attribute">listen</span> [::]:<span class="number">443</span> ssl http2;</span><br><span class="line">  <span class="attribute">ssl_certificate</span> /usr/local/nginx/conf/ssl/test.eber.vip.crt;</span><br><span class="line">  <span class="attribute">ssl_certificate_key</span> /usr/local/nginx/conf/ssl/test.eber.vip.key;</span><br><span class="line">  <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">  <span class="attribute">ssl_ciphers</span> TLS13-AES-<span class="number">256</span>-GCM-SHA384:TLS13-CHACHA20-POLY1305-SHA256:TLS13-AES-<span class="number">128</span>-GCM-SHA256:TLS13-AES-<span class="number">128</span>-CCM-<span class="number">8</span>-SHA256:TLS13-AES-<span class="number">128</span>-CCM-SHA256:EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br><span class="line">  <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">  <span class="attribute">ssl_session_timeout</span> <span class="number">10m</span>;</span><br><span class="line">  <span class="attribute">ssl_session_cache</span> builtin:<span class="number">1000</span> shared:SSL:<span class="number">10m</span>;</span><br><span class="line">  <span class="attribute">ssl_buffer_size</span> <span class="number">1400</span>;</span><br><span class="line">  <span class="attribute">add_header</span> Strict-Transport-Security max-age=<span class="number">15768000</span>; <span class="comment"># HSTS头配置</span></span><br><span class="line">  <span class="attribute">ssl_stapling</span> <span class="literal">on</span>;</span><br><span class="line">  <span class="attribute">ssl_stapling_verify</span> <span class="literal">on</span>;</span><br><span class="line">  <span class="attribute">server_name</span> test.eber.vip;</span><br><span class="line">  <span class="attribute">access_log</span> /usr/local/nginx/wwwlogs/test.eber.vip_nginx.log combined;</span><br><span class="line">  <span class="attribute">if</span> (<span class="variable">$ssl_protocol</span> = <span class="string">&quot;&quot;</span>) &#123; <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>; &#125;</span><br><span class="line">  <span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1:8080; <span class="comment"># 目标服务地址</span></span><br><span class="line">    <span class="attribute">include</span> proxy.conf; <span class="comment"># 引入自定义的反代配置</span></span><br><span class="line">    <span class="comment"># 支持ws</span></span><br><span class="line">    <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="section">location</span> <span class="regexp">~ /(\.user\.ini|\.ht|\.git|\.svn|\.project|LICENSE|README\.md)</span> &#123;</span><br><span class="line">    <span class="attribute">deny</span> all;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acme.sh </tag>
            
            <tag> SSL </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>debian11增强命令自动补全功能</title>
      <link href="/post/2023/04/10/38742/"/>
      <url>/post/2023/04/10/38742/</url>
      
        <content type="html"><![CDATA[<p>最近几年从redhat系切换到debian系了，不过经常使用的是ubuntu发行版。最近因为折腾S905等一些arm&#x2F;x86低性能玩意，所以又折腾了debian11。装好系统后才发现之前ubuntu20.04自带的<code>bash-completion</code>并没有在debian11中默认安装【debian确实精简😂】，所以这里记录一下如何安装和使用。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install bash-completion</span><br></pre></td></tr></table></figure><p>安装完会发现并不能直接使用，因为没有加载到环境里面。需要修改<code>/etc/bash.bashrc</code>文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># enable bash completion in interactive shells 这里已经说明了直接把下面if语句的注释去掉即可。</span></span><br><span class="line"><span class="comment">#if ! shopt -oq posix; then</span></span><br><span class="line"><span class="comment">#  if [ -f /usr/share/bash-completion/bash_completion ]; then</span></span><br><span class="line"><span class="comment">#    . /usr/share/bash-completion/bash_completion</span></span><br><span class="line"><span class="comment">#  elif [ -f /etc/bash_completion ]; then</span></span><br><span class="line"><span class="comment">#    . /etc/bash_completion</span></span><br><span class="line"><span class="comment">#  fi</span></span><br><span class="line"><span class="comment">#fi</span></span><br></pre></td></tr></table></figure><p>因为<code>/etc/bashrc</code>(debian系是&#x2F;etc&#x2F;bash.bashrc)会自动加载，所以重新登入终端即可生效。也可以手动执行<code>source /etc/bash.bashrc</code>使之生效。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比如我想查看apt命令的参数，直接输入apt 然后连按两次[tab]键即可自动补全。</span></span><br><span class="line">root@debian:~<span class="comment"># apt </span></span><br><span class="line">autoclean     build-dep     depends       edit-sources  install       policy        remove        showsrc       upgrade       </span><br><span class="line">autopurge     changelog     dist-upgrade  full-upgrade  list          purge         search        <span class="built_in">source</span>        </span><br><span class="line">autoremove    clean         download      <span class="built_in">help</span>          moo           rdepends      show          update </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Debian </tag>
            
            <tag> bash-completion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国电信烽火HG5143F光猫开启telnet获取超级密码</title>
      <link href="/post/2023/04/08/18531/"/>
      <url>/post/2023/04/08/18531/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>新办的电信千兆宽带，光猫是烽火HG5143F，这个光猫的管理界面是通过telnet访问的，但是默认是关闭的，需要开启才能访问。</p><h3 id="开启telnet"><a href="#开启telnet" class="headerlink" title="开启telnet"></a>开启telnet</h3><ol><li>电脑连接光猫的LAN口，IP地址设置为192.168.1.2，子网掩码255.255.255.0（依据光猫初始配置贴纸进行灵活配置）</li><li>打开浏览器，输入<code>http://192.168.1.1:8080/cgi-bin/telnetenable.cgi?telnetenable=1&amp;key=</code> ，其中key的值是光猫初始配置贴纸上的MAC地址，去掉冒号，全部大写。</li><li>如果浏览器显示<code>telnetenable=1</code> 或 <code>telnet开启</code> ，则表示开启成功。</li></ol><h3 id="获取超级密码"><a href="#获取超级密码" class="headerlink" title="获取超级密码"></a>获取超级密码</h3><ol><li>打开电脑终端，输入<code>telnet 192.168.1.1</code> 回车，如果出现<code>login:</code> ，则表示telnet开启成功。</li><li>输入<code>telecom</code> 回车，如果出现<code>Password:</code> ，则表示用户名正确。</li><li>输入<code>nE7jA%5m</code> 回车，如果出现<code>$</code> ，则表示登录成功。</li><li>这时登录的是普通用户，然后输入<code>su</code> 回车，出现<code>Password:</code> ，这时输入密码：<code>Fh@5554A0</code>，这里的5554A0改成你自己光猫的MAC地址后六位，如果终端显示<code>#</code>则表示切换到超级用户成功。</li><li>输入命令进入工厂模式：<code>load_cli factory</code></li><li>输入命令获取管理员用户名：<code>show admin_name</code></li><li>输入命令获取管理员密码：<code>show admin_pwd</code> 回显的这个密码就是光猫的超级密码。</li></ol><p>OK！现在就可以直接去光猫web管理端登录了，去修改桥接模式或修改其他普通用户无法修改的设置项！</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>⚠️ 不需要记录这里的超级密码，大部分设备重启后再进行获取就会变更。每次需要用的时候就重复上述步骤获取即可！</p>]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光猫 </tag>
            
            <tag> Telnet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Charles教程3 - 修改请求和响应</title>
      <link href="/post/2022/06/19/5631/"/>
      <url>/post/2022/06/19/5631/</url>
      
        <content type="html"><![CDATA[<h3 id="1、手动选择修改请求"><a href="#1、手动选择修改请求" class="headerlink" title="1、手动选择修改请求"></a>1、手动选择修改请求</h3><p><strong>这种适合需要手动修改请求并重发的场景。（需要修改host不需要修改响应）</strong></p><p>当我们捕获到想要修改的接口后，可选择接口名然后点击编辑图标进入<br><img src="/../img/charles/20220715150129.png" alt="20220715150129.png"></p><p>在编辑界面，可以编辑请求方式、URL、HTTP版本、请求头、鉴权、入参等。</p><p>例如：我修改了URL，让他请求我本地idea中启动的服务进行本地调试。</p><p><img src="/../img/charles/20220715150424.png" alt="20220715150424.png"></p><p>修改完毕后直接点击 Execute 执行请求即可！</p><h3 id="2、断点的方式自动进入请求和响应的修改"><a href="#2、断点的方式自动进入请求和响应的修改" class="headerlink" title="2、断点的方式自动进入请求和响应的修改"></a>2、断点的方式自动进入请求和响应的修改</h3><p><strong>这种适合触发后自动进入编辑（可编辑请求和响应，但无法修改host）</strong></p><p>当我们捕获到想要修改的接口后，可选择接口名然后右键选中 Breakpoints ，然后当你再触发该接口时会自动跳到编辑页面</p><p><img src="/../img/charles/20220715153711.png" alt="20220715153711.png"></p><p>请求头、参数等修改完之后可以直接点击 Execute 发送请求，然后等待响应后也会自动跳转到响应编辑页面</p><p>例如：我这里修改了响应数据中的 message 和 data.origin</p><p><img src="/../img/charles/20220715153917.png" alt="20220715153917.png"></p><p>同样点击 Execute 之后就可以把响应发给客户端。</p><p>🌧️ 预告 ：下个教程会写Map Remote Settings 和 Map Local Settings 的用法。</p>]]></content>
      
      
      <categories>
          
          <category> 开发与测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Charles </tag>
            
            <tag> 抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓7以上系统安装Charles证书到系统区</title>
      <link href="/post/2022/06/11/2897/"/>
      <url>/post/2022/06/11/2897/</url>
      
        <content type="html"><![CDATA[<p>👉 本文以红米手机（Android 10）为例，其他安卓手机流程基本一致。</p><p>工欲善其事，必先利其器：</p><ol><li>电脑（win、mac、linux均可）</li><li>一个已经获取root权限的手机</li><li>adb</li><li>手和脑子</li></ol><h2 id="一、安装adb"><a href="#一、安装adb" class="headerlink" title="一、安装adb"></a>一、安装adb</h2><p>我们先去 <a href="https://developer.android.com/studio/releases/platform-tools">官网</a> 下载对应你电脑版本的 <a href="https://developer.android.com/studio/releases/platform-tools">Android SDK Platform-Tools</a>  此时你会得到一个zip包，解压等待操作。</p><ul><li><p>win：windows环境下直接解压zip包，然后在环境变量Path中添加该路径(例如C:\platform-tools)。<br><img src="https://up.eber.vip/Think-Me/img/main/upload/20220610114631.png"></p></li><li><p>mac和linux：mac和linux环境下直接解压zip包，然后直接</p></li></ul><p><code>export PATH=$&#123;PATH&#125;:/Users/ebert/Documents/platform-tools</code> 即可。</p><p><img src="https://up.eber.vip/Think-Me/img/main/upload/20220610115537.png"></p><p>无论哪个环境哪种方式安装，只要搞完之后执行adb命令会出现帮助信息即为成功。</p><h2 id="二、开搞"><a href="#二、开搞" class="headerlink" title="二、开搞"></a>二、开搞</h2><h3 id="1-证书导出"><a href="#1-证书导出" class="headerlink" title="1. 证书导出"></a>1. 证书导出</h3><p>启动Charles（其他抓包软件操作类似），依次点击 Help -&gt; SSL Proxying -&gt; Save Charles Root Certificate… 将证书导出（windows下有个小bug，导出的证书名字会是你选择的目录名，并且位置是和你所选的文件夹同级）</p><p><img src="https://up.eber.vip/Think-Me/img/main/upload/20220614100329.png"></p><h3 id="2-证书转换"><a href="#2-证书转换" class="headerlink" title="2. 证书转换"></a>2. 证书转换</h3><p>导出的这个 <code>charles-ssl-proxying-certificate.pem</code> 证书不能直接使用，而是需要先计算出这个证书主题（subject）的MD5值。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl x509 -subject_hash_old -in charles-ssl-proxying-certificate.pem|head -n 1</span><br></pre></td></tr></table></figure><h3 id="3-证书重命名"><a href="#3-证书重命名" class="headerlink" title="3. 证书重命名"></a>3. 证书重命名</h3><p>然后将导出的证书重命名为 <code>md5值 + .0</code> 的格式</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv charles-ssl-proxying-certificate.pem de70e315.0</span><br></pre></td></tr></table></figure><p>当然了，重命名也可以直接在GUI上进行，例如windows系统直接右键点击文件然后选择重命名即可。</p><h3 id="4-将证书导入手机系统证书区"><a href="#4-将证书导入手机系统证书区" class="headerlink" title="4. 将证书导入手机系统证书区"></a>4. 将证书导入手机系统证书区</h3><ul><li>先使用你习惯的方式将文件传入手机中，这里我是用 <code>adb push</code> 。（你甚至可以用QQ，微信等任何方式将文件传入手机中）</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb push de70e315.0 /sdcard</span><br></pre></td></tr></table></figure><p>👉 我这里保存到了 <code>/sdcard</code> 目录，现在的安卓手机自带储存的目录名一般为 <code>sdcard</code> 所以我这个可以理解为当前”手机文件管理“的根目录下。</p><ul><li>然后将证书移动到 <code>/system/etc/security/cacerts</code> 目录下，不过默认这个目录是只读目录，所以“暴力一点”重新挂载一下根分区即可。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell # 进入手机shell</span><br><span class="line">su # 切换为root身份</span><br><span class="line">mount -o rw,remount / # 重新挂载根分区为可读写</span><br><span class="line">mv /sdcard/de70e315.0 /system/etc/security/cacerts # 移动证书</span><br><span class="line">chmod 644 /system/etc/security/cacerts/de70e315.0 # 更改文件权限</span><br><span class="line">exit # 退出root身份</span><br><span class="line">exit # 退出shell连接</span><br><span class="line">adb reboot # 重启手机</span><br></pre></td></tr></table></figure><p>⚠️ 你在移动证书到 <code>/system/etc/security/cacerts</code> 时可能会提示空间不足，这时你需要删除一个无用的系统内置app即可，我这里删除的是“电商助手” <code>rm -rf /system/app/mab</code> 。</p>]]></content>
      
      
      <categories>
          
          <category> 开发与测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抓包 </tag>
            
            <tag> 安卓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于limits不生效的问题</title>
      <link href="/post/2022/04/16/29640/"/>
      <url>/post/2022/04/16/29640/</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要："><a href="#前情提要：" class="headerlink" title="前情提要："></a>前情提要：</h2><p>最近几天使用trojan-go总是遇到不能上网的情况，经过一系列的排查发现并不是域名或服务器被墙了。然后我开始查trojan的日志，发现有很多<code>read: connection timed out</code>的报错。初步猜测应该是连接上限了，于是我调整了内核参数<code>fs.file-max=1000000</code>。本以为就不会出现这种情况了，但事与愿违，一天之后又出现同样的问题！！！我有点懵了，我开始怀疑trojan没有继承刚才的open files配置，于是又开始了新一轮的排查：</p><ol><li>先找出trojan的PID</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ip-172-26-12-41:~# ps -ef|grep trojan</span><br><span class="line">root        2080       1  0 May26 ?        00:00:33 /usr/bin/trojan/trojan -config /usr/local/etc/trojan/config.json</span><br><span class="line">root       35254       1  0 03:00 ?        00:00:03 /usr/local/bin/trojan web -p 1080</span><br><span class="line">root       40802   39795  0 11:05 pts/0    00:00:00 grep --color=auto trojan</span><br></pre></td></tr></table></figure><ol start="2"><li>然后查询2080的Soft Limit</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ip-172-26-12-41:~# cat /proc/2080/limits </span><br><span class="line">Limit                     Soft Limit           Hard Limit           Units     </span><br><span class="line">Max cpu time              unlimited            unlimited            seconds   </span><br><span class="line">Max file size             unlimited            unlimited            bytes     </span><br><span class="line">Max data size             unlimited            unlimited            bytes     </span><br><span class="line">Max stack size            8388608              unlimited            bytes     </span><br><span class="line">Max core file size        0                    unlimited            bytes     </span><br><span class="line">Max resident set          unlimited            unlimited            bytes     </span><br><span class="line">Max processes             3882                 3882                 processes </span><br><span class="line">Max open files            1024                 524288               files     </span><br><span class="line">Max locked memory         65536                65536                bytes     </span><br><span class="line">Max address space         unlimited            unlimited            bytes     </span><br><span class="line">Max file locks            unlimited            unlimited            locks     </span><br><span class="line">Max pending signals       3882                 3882                 signals   </span><br><span class="line">Max msgqueue size         819200               819200               bytes     </span><br><span class="line">Max nice priority         0                    0                    </span><br><span class="line">Max realtime priority     0                    0                    </span><br><span class="line">Max realtime timeout      unlimited            unlimited            us</span><br></pre></td></tr></table></figure><p>发现Max open files的Soft Limit依旧是1024，并且Hard Limit是524288 这并不是我刚才设置的1000000。</p><p>经过在对trojan服务的定位，发现该服务是以系统服务的方式运行，并没有去遵循用户服务的limits配置。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>针对用户服务的limits配置</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ip-172-26-12-41:~# sysctl -w fs.file-max=1000001</span><br><span class="line">fs.file-max = 1000001</span><br><span class="line">root@ip-172-26-12-41:~# sysctl -p</span><br></pre></td></tr></table></figure><p>或者直接编辑 <code>/etc/sysctl.conf</code> 文件追加 <code>fs.file-max = 1000000</code> 然后保存重启即可。</p><ol start="2"><li>针对系统服务</li></ol><ul><li>全局设置</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ip-172-26-12-41:~# vi /etc/systemd/system.conf </span><br></pre></td></tr></table></figure><p><img src="https://up.eber.vip/Think-Me/img/main/upload/202205281125454.png"></p><p>找到 <code>DefaultLimitNOFILE</code> 然后修改为 1000000 或者是 102400:1000000 ，前者软硬均为1000000、后者软硬分开设置。【&lt;Soft Limit&gt;:&lt;Hard Limit&gt;】</p><ul><li>单服务的限制</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ip-172-26-12-41:~# vi /etc/systemd/system/trojan.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=trojan-go</span><br><span class="line">After=network.target network-online.target nss-lookup.target mysql.service mariadb.service mysqld.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">LimitNOFILE=65535 // 这里加入LimitNOFILE的配置即可</span><br><span class="line">StandardError=journal</span><br><span class="line">ExecStart=/usr/bin/trojan/trojan -config /usr/local/etc/trojan/config.json</span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=3s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">// 保存文件后需要重载服务，然后再重启服务即可生效</span><br><span class="line">root@ip-172-26-12-41:~# systemctl daemon-reload </span><br><span class="line">root@ip-172-26-12-41:~# systemctl restart trojan.service</span><br><span class="line">root@ip-172-26-12-41:~# ps -ef|grep trojan</span><br><span class="line">root       35254       1  0 03:00 ?        00:00:03 /usr/local/bin/trojan web -p 1080</span><br><span class="line">root       41521       1  0 11:41 ?        00:00:00 /usr/bin/trojan/trojan -config /usr/local/etc/trojan/config.json</span><br><span class="line">root       41544   39795  0 11:41 pts/0    00:00:00 grep --color=auto trojan</span><br><span class="line">root@ip-172-26-12-41:~# cat /proc/41521/limits </span><br><span class="line">Limit                     Soft Limit           Hard Limit           Units     </span><br><span class="line">Max cpu time              unlimited            unlimited            seconds   </span><br><span class="line">Max file size             unlimited            unlimited            bytes     </span><br><span class="line">Max data size             unlimited            unlimited            bytes     </span><br><span class="line">Max stack size            8388608              unlimited            bytes     </span><br><span class="line">Max core file size        0                    unlimited            bytes     </span><br><span class="line">Max resident set          unlimited            unlimited            bytes     </span><br><span class="line">Max processes             3882                 3882                 processes </span><br><span class="line">Max open files            65535                65535                files     </span><br><span class="line">Max locked memory         65536                65536                bytes     </span><br><span class="line">Max address space         unlimited            unlimited            bytes     </span><br><span class="line">Max file locks            unlimited            unlimited            locks     </span><br><span class="line">Max pending signals       3882                 3882                 signals   </span><br><span class="line">Max msgqueue size         819200               819200               bytes     </span><br><span class="line">Max nice priority         0                    0                    </span><br><span class="line">Max realtime priority     0                    0                    </span><br><span class="line">Max realtime timeout      unlimited            unlimited            us</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Charles教程2 - 抓https包</title>
      <link href="/post/2022/03/06/45371/"/>
      <url>/post/2022/03/06/45371/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：本教程基于Mac-iPhone环境，Windows和安卓设备不是完全一致，但按照逻辑进行配置也没啥问题。"><a href="#前言：本教程基于Mac-iPhone环境，Windows和安卓设备不是完全一致，但按照逻辑进行配置也没啥问题。" class="headerlink" title="前言：本教程基于Mac + iPhone环境，Windows和安卓设备不是完全一致，但按照逻辑进行配置也没啥问题。"></a>前言：本教程基于Mac + iPhone环境，Windows和安卓设备不是完全一致，但按照逻辑进行配置也没啥问题。</h2><h3 id="1-配置调优"><a href="#1-配置调优" class="headerlink" title="1. 配置调优"></a>1. 配置调优</h3><ul><li><p>打开Proxy - Proxy Settings - macOS 取消勾选Enable macOS proxy on launch。<br>👉 个人不喜欢每次软件打开就默认抓本地电脑的包<br><img src="/../img/charles/202204272339095.png" alt="202204272339095.png"></p></li><li><p>打开Proxy - Access Control Settings 将0.0.0.0&#x2F;0 Add到IP Range中。<br>👉 这样就不用每次有新设备进来手动去allow了<br><img src="/../img/charles/202204272339657.png" alt="202204272339657.png"></p></li></ul><h3 id="2-证书配置"><a href="#2-证书配置" class="headerlink" title="2. 证书配置"></a>2. 证书配置</h3><ul><li>电脑端(服务端)：Help - SSL Proxying - Install Charles Root Cartificate 安装电脑端根证书。<br><img src="/../img/charles/202204272343306.png" alt="202204272343306.png"><br>⚠️ Mac比Windows多了一个步骤：手动去Keychain Access 找到该证书选择永远信任。(根据你的安装位置找，你的不一定在login。也可能在system或system roots中)<br><img src="/../img/charles/202204272357980.png" alt="202204272357980.png"></li><li>移动端(客户端)：Help - SSL Proxying - Install Charles Root Cartificate on aMobile Device or Remote Browser 后有如下图提示：<br><img src="/../img/charles/202204272345446.png" alt="202204272345446.png"><br>👉 此时手机Wi-Fi中设置代理到电脑局域网ip的8888端口，然后打开浏览器访问 <a href="chls.pro/ssl">chls.pro&#x2F;ssl</a> 直接下载证书到设备中。此时手机会提示让你到 “设置” 中安装证书。<br>⚠️ iPhone手机iOS10及更高系统需要到 “通用 - 关于手机 - 证书信任设置” 点击信任根证书。<br><img src="/../img/charles/202204272353568.jpg" alt="202204272353568.jpg"></li></ul><h3 id="3-愉快的抓包"><a href="#3-愉快的抓包" class="headerlink" title="3. 愉快的抓包"></a>3. 愉快的抓包</h3><p>🎉 🎉 🎉 到现在为止我们已经可以开始用Charles愉快的抓包了。</p><p>更多教程，请等待。。。</p>]]></content>
      
      
      <categories>
          
          <category> 开发与测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Charles </tag>
            
            <tag> 抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx的配置教程 - location多级目录</title>
      <link href="/post/2022/03/05/50754/"/>
      <url>/post/2022/03/05/50754/</url>
      
        <content type="html"><![CDATA[<h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><p>👉 有时候我们会有这么一种场景：一个域名下需要挂多个项目或者是多个服务。这时就需要我们通过多个location去处理不同的服务请求。（当然了，一般情况下都是一个子域名对应一个服务）</p><h3 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h3><ul><li>root方式指定</li></ul><pre><code class="nginx">    location /p1/ &#123;        root /www/project; # 资源目录在/www/project/p1/        index index.html;    &#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* alias方式指定</span><br><span class="line"></span><br><span class="line">```nginx</span><br><span class="line">location /p1/ &#123;</span><br><span class="line">alias /www/project/; # 资源目录在/www/project/</span><br><span class="line">index index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>### 总结👉 root 指定上级目录，并且该上级目录 一定要含有locatoin指定名称的同名目录。👉 alias 指定的目录是准确的，给location指定一个目录。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Charles教程1 - 安装及破解</title>
      <link href="/post/2022/02/26/59239/"/>
      <url>/post/2022/02/26/59239/</url>
      
        <content type="html"><![CDATA[<h3 id="前言：我为什么使用Charles？"><a href="#前言：我为什么使用Charles？" class="headerlink" title="前言：我为什么使用Charles？"></a>前言：我为什么使用Charles？</h3><p>👉  博主一直是Mac用户，很久之前Fiddler和Wireshark(侧重点也不同)在Mac系统上的适配不是很好，所以就用了适配比较好的Charles。第一次接触Charles应该是2017年，从那以后一直再持续使用，没再宠幸过另外俩。【这大概是一个迟到了四五年的教程了😂】</p><h3 id="1-Charles简述"><a href="#1-Charles简述" class="headerlink" title="1. Charles简述"></a>1. Charles简述</h3><ul><li>官方描述：<br><a href="https://www.charlesproxy.com/overview/about-charles/">Charles is an HTTP proxy &#x2F; HTTP monitor &#x2F; Reverse Proxy that enables a developer to view all of the HTTP and SSL &#x2F; HTTPS traffic between their machine and the Internet. This includes requests, responses and the HTTP headers (which contain the cookies and caching information).</a></li><li>博主描述：<br>Charles是一个使用Java语言开发的跨平台抓包工具。它可以让用户能够通过本地计算机查看HTTP、HTTPS、HTTP&#x2F;2等流量，其中包括请求和响应、HTTP头和元数据。</li></ul><h3 id="2-Charles下载和安装"><a href="#2-Charles下载和安装" class="headerlink" title="2. Charles下载和安装"></a>2. Charles下载和安装</h3><ul><li><p>下载<br>Charles的下载很简单，直接去 <a href="https://www.charlesproxy.com/download/">官网下载页</a> 选择对应系统的安装包进行下载即可。</p></li><li><p>安装<br>安装就直接无脑下一步即可。</p></li></ul><h3 id="3-破解"><a href="#3-破解" class="headerlink" title="3. 破解"></a>3. 破解</h3><ul><li>点击 <a href="https://go.dev/play/p/Qtt2CmHbTzU">链接</a> 进入go在线代码运行平台。直接点击Run，在下方会出现类似下方的输出：</li></ul><p><img src="/../img/charles/202204280012492.png" alt="202204280012492.png"></p><ul><li><p>如果想改名字则直接将 name :&#x3D; “charles” 的赋值修改一下即可。</p></li><li><p>最后打开Charles — Help — Register 填入信息即可完成破解。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发与测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Charles </tag>
            
            <tag> 抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>acme.sh踩坑记录</title>
      <link href="/post/2022/02/20/24919/"/>
      <url>/post/2022/02/20/24919/</url>
      
        <content type="html"><![CDATA[<h2 id="1、dnspod解析的域名来申请泛域名证书"><a href="#1、dnspod解析的域名来申请泛域名证书" class="headerlink" title="1、dnspod解析的域名来申请泛域名证书"></a>1、dnspod解析的域名来申请泛域名证书</h2><p>⚠️ 因为申请泛域名证书鉴权需要使用dns验证模式，而不是webroot模式。所以这个时候需要使用dnsapi的密钥。具体每家的设置请看<a href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi#how-to-use-dns-api">这里</a>。<br>这里的坑是：dnspod的腾讯云API密钥和DNSPod Token。这两个是很多人容易搞错的地方。如下图所示：<br><img src="/../img/acme/202203072359737.png" alt="202203072359737.png"><br>这里acme使用的是DNSPod Token</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> DP_Id=<span class="string">&quot;297228&quot;</span> <span class="comment">#这个纯数字就是DP_Id</span></span><br><span class="line"><span class="built_in">export</span> DP_Key=<span class="string">&quot;xxxxxxxxxxx&quot;</span> <span class="comment"># Token就是DP_Key</span></span><br></pre></td></tr></table></figure><p>🔥 还一个要注意的地方就是：dnspod是有dnspod.cn和dnspod.com两个服务的。注意看一下你是国内版还是国际版。它俩的参数名称是不一样的！！！</p><h2 id="2、Processing-The-CA-is-processing-your-order-please-just-wait"><a href="#2、Processing-The-CA-is-processing-your-order-please-just-wait" class="headerlink" title="2、Processing, The CA is processing your order, please just wait"></a>2、Processing, The CA is processing your order, please just wait</h2><p>⚠️ 第二个坑就是申请证书到最后一直提示</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Processing, The CA is processing your order, please just <span class="built_in">wait</span>. (1/30)</span><br><span class="line">Processing, The CA is processing your order, please just <span class="built_in">wait</span>. (2/30)</span><br><span class="line">..... <span class="comment"># 一直到30/30 报timeout。</span></span><br></pre></td></tr></table></figure><p>这里的原因是CA机构zerossl经常出现需要等待很久的情况而导致超时了还没有得到响应。所以这里的解决方案就是更换默认的CA。</p><p>➡️ 直接到.acme.sh文件夹内执行<code>acme.sh --set-default-ca  --server letsencrypt</code>设置一下默认的CA即可。</p><p>🔥 只需要设置一次即可，后续申请证书会自动使用letsencrypt进行验证。</p>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acme.sh </tag>
            
            <tag> SSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java项目四步排查CPU占用高的问题</title>
      <link href="/post/2022/02/12/47604/"/>
      <url>/post/2022/02/12/47604/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不止一次写过CPU飙高的问题排查(当时并不仅限于Java)，不过由于各种原因这个小破站换了N多个虚拟主机、服务器、域名等中间丢失了很多珍贵的原创博客。最近闲暇的时候看了一下仅存的2018年写的一篇垃圾水文😂当时没有图文并茂的去展现整个流程，今天重新以图文的方式记录一遍。</p><h2 id="实战准备"><a href="#实战准备" class="headerlink" title="实战准备"></a>实战准备</h2><p>首先使用micronaut快速生成一个项目：<code>mn create-app example.micronaut.complete</code></p><p>⚠️ 这个Micronaut是Java微服务框架的一种，可类比springboot，具体的你可以上网找资料看一下。这里不展开讨论，这里使用它的原因是因为它比较快。。。仅此而已👌。 当然了，你也可以用springboot或其他你喜欢的方式生成一个死循环接口。</p><p>然后创建controller类，写类似下面这种死循环的请求接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.micronaut;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.micronaut.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> io.micronaut.http.annotation.Controller;</span><br><span class="line"><span class="keyword">import</span> io.micronaut.http.annotation.Get;</span><br><span class="line"><span class="keyword">import</span> io.micronaut.http.annotation.Produces;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line">    <span class="meta">@Get</span></span><br><span class="line">    <span class="meta">@Produces(MediaType.TEXT_PLAIN)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &gt; -<span class="number">1</span> ; i++) &#123; <span class="comment">// 这里 i &gt; -1 始终为true</span></span><br><span class="line">            System.out.println(i * i++); <span class="comment">// 这里随便写个计算 并打印输出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后打个jar包放到Linux服务器上运行，在浏览器中请求test接口去触发死循环。</p><p><img src="https://up.eber.vip/Think-Me/img/main/upload/202202171703894.png"></p><p>终端会持续输出计算结果，如果该Linux服务配置较低不出意外的话现在已经比较卡了。</p><h2 id="1、首先祭出大杀器：top"><a href="#1、首先祭出大杀器：top" class="headerlink" title="1、首先祭出大杀器：top"></a>1、首先祭出大杀器：top</h2><p>Linux中top命令用于实时显示 process 的动态。(引用自<a href="https://www.runoob.com/linux/linux-comm-top.html">runoob</a>)</p><p>直接执行<code>top</code>命令然后<code>shift + p</code>按照<code>%CPU</code>去排序</p><p><img src="https://up.eber.vip/Think-Me/img/main/upload/202202171712507.png"></p><p>这时我们发现<code>PID</code>为<code>605108</code>的Java进程CPU占用开始飙高。</p><h2 id="2、其次再利用top：top-p-PID-H"><a href="#2、其次再利用top：top-p-PID-H" class="headerlink" title="2、其次再利用top：top -p PID -H"></a>2、其次再利用top：top -p PID -H</h2><p>这一步我们来查询这个Java进程中哪个线程的CPU占用在飙高。</p><p><img src="https://up.eber.vip/Think-Me/img/main/upload/202202171713900.png"></p><p>这个地方显示<code>PID</code>为<code>605162</code>的线程CPU在飙高。</p><h2 id="3、再次祭出另外一个大杀器：jstack"><a href="#3、再次祭出另外一个大杀器：jstack" class="headerlink" title="3、再次祭出另外一个大杀器：jstack"></a>3、再次祭出另外一个大杀器：jstack</h2><p>使用<code>jstack PID &gt; 1.txt</code>将堆栈信息保存到1.txt。</p><ul><li>注意这里的PID是Java进程的PID而不是线程的。</li><li>顺带着将605162转换为16进制(最后一行root前的<code>93bea</code>即为转换结果)。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># jstack 605108 &gt; 1.txt</span></span><br><span class="line">root@ubuntu:~<span class="comment"># printf &quot;%x&quot; 605162</span></span><br><span class="line">93bearoot@ubuntu:~<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>⚠️ 这里的”%x”是格式化为16进制的意思，你可以通过任何你喜欢的方式转换，甚至电脑上的程序员计算器都行。</p><h2 id="4、最后分析文件找出”水鬼”"><a href="#4、最后分析文件找出”水鬼”" class="headerlink" title="4、最后分析文件找出”水鬼”"></a>4、最后分析文件找出”水鬼”</h2><p>用<code>vim</code>打开文件并搜索<code>93bea</code></p><p><img src="https://up.eber.vip/Think-Me/img/main/upload/202202171721032.png"></p><p>我们发现下面这么一行描述。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">at example.micronaut.DemoController.index(DemoController.java:14)</span><br></pre></td></tr></table></figure><p>在example.micronaut.DemoController类中index方法第14行这么一个信息。</p><p>那么我们去找一下刚才我们写的方法，看看问题是不是在14附近。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(i * i++);</span><br></pre></td></tr></table></figure><p>经过代码中的查找我们发现确实我们当时创建的死循环执行就是在这里。</p><p>✖️ OK，这就是今天带来的四步排查法。是不是很简单？</p>]]></content>
      
      
      <categories>
          
          <category> 开发与测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从一个请求到互联网协议</title>
      <link href="/post/2022/02/06/37649/"/>
      <url>/post/2022/02/06/37649/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是互联网协议"><a href="#一、什么是互联网协议" class="headerlink" title="一、什么是互联网协议"></a>一、什么是互联网协议</h2><p>网络协议是在网络环境下运行的所有设备之间互相通信的规则的集合，它定义了设备之间通信时数据交换的格式和格式的解释。</p><h2 id="二、分层模型"><a href="#二、分层模型" class="headerlink" title="二、分层模型"></a>二、分层模型</h2><p>提起分层模型，一定有人会有疑问🤔️。为什么有说七层的有说五层的还有说四层的？</p><h3 id="2-1、首先来说OSI七层模型"><a href="#2-1、首先来说OSI七层模型" class="headerlink" title="2.1、首先来说OSI七层模型"></a>2.1、首先来说OSI七层模型</h3><p><img src="https://up.eber.vip/Think-Me/img/main/upload/202202161515220.png"></p><ul><li>首先OSI七层模型并不是一个标准，而是一个概念。</li><li>其次OSI并没有得到广泛的认可</li><li>最后这个模型各层的名字大家不需要去死背硬记，没有意义。下面我会有例子讲到各层解决的问题。</li></ul><h3 id="2-2、其次是TCP-x2F-IP参考模型"><a href="#2-2、其次是TCP-x2F-IP参考模型" class="headerlink" title="2.2、其次是TCP&#x2F;IP参考模型"></a>2.2、其次是TCP&#x2F;IP参考模型</h3><p><img src="https://up.eber.vip/Think-Me/img/main/upload/202202161514843.png"></p><ul><li>实际上TCP&#x2F;IP和OSI模型组并不能如上图所示精确的匹配</li><li>网络中最核心的技术就是传输层和网络层技术，所以无论是四层还是五层模型这两层都被完整保留</li><li>TCP&#x2F;IP参考模型，更加侧重的是互联网通信核心（也是就是围绕TCP&#x2F;IP协议展开的一系列通信协议）的分层，因此它不去管此流程中不相关的协议;其次，之所以说他是参考模型，是因为他本身也是OSI模型中的一部分，因此参考OSI模型对其分层。</li></ul><h3 id="2-3、五层模型"><a href="#2-3、五层模型" class="headerlink" title="2.3、五层模型"></a>2.3、五层模型</h3><p><img src="https://up.eber.vip/Think-Me/img/main/upload/202202161539787.png"></p><ul><li>五层模型是结合了OSI七层和TCP&#x2F;IP四层模型为了方便学习计算机网络原理的产物。</li></ul><p>这里下面再引用一个我认为做的还不错的网图（Google搜图搜的，如有侵权请告知。）</p><p><img src="https://up.eber.vip/Think-Me/img/main/upload/202202171115168.png"></p><h2 id="三、现在讲一下从设备A到设备B的数据交互"><a href="#三、现在讲一下从设备A到设备B的数据交互" class="headerlink" title="三、现在讲一下从设备A到设备B的数据交互"></a>三、现在讲一下从设备A到设备B的数据交互</h2><h3 id="3-1、如果现在小A要和小B通信，那么从物理层讲起，最简单的是不是拿一根网线连接A-gt-B"><a href="#3-1、如果现在小A要和小B通信，那么从物理层讲起，最简单的是不是拿一根网线连接A-gt-B" class="headerlink" title="3.1、如果现在小A要和小B通信，那么从物理层讲起，最简单的是不是拿一根网线连接A-&gt;B"></a>3.1、如果现在小A要和小B通信，那么从物理层讲起，最简单的是不是拿一根网线连接A-&gt;B</h3><p>这一层一般是以物理形式存在的，使用双绞线、光纤等其他方式进行设备之间的连接。他可以传输0101这样的二进制电信号。</p><p>⚠️ 现在有一个问题就是他们之间可能不懂对方的0101代表什么，这个时候就需要数据链路层上场了。</p><h3 id="3-2、数据链路层这里去定义0101的分组方式和代表的意义"><a href="#3-2、数据链路层这里去定义0101的分组方式和代表的意义" class="headerlink" title="3.2、数据链路层这里去定义0101的分组方式和代表的意义"></a>3.2、数据链路层这里去定义0101的分组方式和代表的意义</h3><p>该层下主要是以太网，以太网规定一组电信号构成一个数据包 叫做<code>帧(Frame)</code></p><p>每一帧（Frame）由包头（Head）和数据（Data）组成。其中<code>Head</code>包含该数据包的一些说明项，比如发送者、接受者、数据类型等等；<code>Data</code>则是数据包的具体内容。<code>Head</code>的长度，固定为18字节。<code>Data</code>的长度，最短为46字节，最长为1500字节。因此，一个<code>Frame</code>最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p><p>🪵 现在有个问题是数据包<code>Head</code>中的发送者和接收着如何用全球唯一的名字去标识？</p><p>这个问题实际上可以类比成 你叫张三，他也叫张三。我该如何区分你们？在现实生活中我们是用身份证号作为人的唯一标识。同样以太网规定：每一个过来上网的设备都必须要有<code>网卡</code>，数据包必须从一张网卡传递到另一张网卡。网卡地址就是数据包的发送和接收地址。这个网卡地址就叫做<code>MAC地址</code></p><p>🧱 为什么网卡地址就可以做到唯一？</p><p>这个其实是一种规范：每块网卡在生产时都会标记上厂商的代号和该网卡的内部序列号，例如：</p><p><img src="https://up.eber.vip/Think-Me/img/main/upload/202202161651222.png"></p><ul><li>如上图，MAC地址一共6个字节，用16进制展示，一般写法是每个字节中间用:隔开。</li><li>前三个字节用来标识厂商代号</li><li>后三个字节用来标识该网卡的内部序列号</li></ul><p>如果现在局域网中有ABCD四个设备，数据交换可以通过广播的方式将ARP包发送给每个设备，然后每个设备收到之后去匹配接收着MAC地址，如果是自己则留下，如果不是则丢弃。这样局域网内就可以进行通信了。</p><p>⚠️ 但是又有一个问题：如果此时A要找的设备E，但是设备E没有在局域网里面。这时怎么办？不可能把这个ARP包发给全球所有的设备吧😂（这里只是一个假设，实际上不同子网广播是不互通的）。这样还没开始通信就造成了全球网络瘫痪。</p><h3 id="3-3、现在该网络层上场了"><a href="#3-3、现在该网络层上场了" class="headerlink" title="3.3、现在该网络层上场了"></a>3.3、现在该网络层上场了</h3><p>首先会判断两个通信设备有没有在同一个子网(这个后面会专门写一篇文章去介绍，就是二进制的IP地址与子网掩码进行与运算)</p><p>如果是同一个子网则用广播找<code>设备E</code>，如果不在同一个子网则是用路由找<code>设备E</code>。刚才说到数据链路层用MAC地址作为唯一标识，用ARP协议进行通信，而到了网络层就会是用IP地址作为唯一标识，用IP协议进行通信。</p><p>截止到现在每个设备都有了MAC地址和IP地址。</p><ul><li>MAC地址全球唯一，只与硬件厂商和生产序号有关系。</li><li>公网IP地址为全球唯一，只与网络管理员分配有关系(这一步先不讨论局域网IP)。</li><li>IP地址用来确定设备所在子网，MAC地址用来在子网中确定某一个网卡。</li></ul><p><code>IP数据包</code>也是由包头（Head）和数据（Data）组成，Head包含协议、源地址、目的地址等信息。</p><ul><li>其中前20个字节为固定头部。必须拥有的属性。</li><li>一个数据包总长度最大为65535字节。</li></ul><p><img src="https://up.eber.vip/Think-Me/img/main/upload/202202161815849.png"></p><p>⚠️ 由目标的IP地址和MAC地址可以实现任意两个设备之间的通信，但是又出现一个新的问题：那就是如果确定这个数据包是属于哪个应用程序的？因为咱们的设备可能运行了钉钉、微信等等一大堆应用程序。</p><h3 id="3-4、既然不能确定包所属的应用程序那就再加一个叫传输层的东西"><a href="#3-4、既然不能确定包所属的应用程序那就再加一个叫传输层的东西" class="headerlink" title="3.4、既然不能确定包所属的应用程序那就再加一个叫传输层的东西"></a>3.4、既然不能确定包所属的应用程序那就再加一个叫传输层的东西</h3><p>我们的设备已经有了IP地址，如果想区分应用程序怎么办？很简单—-添加一个叫<code>端口(Port)</code>的东西</p><ul><li>端口是每一个用网卡设备程序的编号。</li><li>每一个端口下都是一个可执行程序。</li><li>端口号是0-65535之间的证书，其中0-1023被称为保留端口号（可以自定义程序使用，但不推荐使用）。</li></ul><p>OK，到这个阶段通过<code>ip+port</code>就可以确定一个设备中某个唯一的程序，进而实现任意两个设备间任意应用程序的通信。</p><p>继续往刚才的IP数据包中添加端口号就有了传输层协议：常见的<code>TCP</code>、<code>UDP</code>协议。</p><p>TCP包和UDP包的区别：</p><ul><li>TCP套接字是四元组标识：源IP、源端口、目的IP、目的端口</li><li>UDP套接字是二元组标识：目的IP、目的端口</li><li>在TCP的传输中只要源IP或源端口任意一个不相同都会被定向到不同的进程去处理；而UDP传输中无论源IP和端口如何变化，只要目的IP和目的端口一致则会交给相同的进程去处理。</li><li>在通常情况下UDP可以是一对一，一对多，多对一，多对多的；而TCP总是一对一的。</li></ul><p>OK，到现在为止数据包已经可以精确的从任意一个设备A的任意一个进程传输到任意一个设备E的任意一个进程。那么有一个新的问题就是：我们人类如果去使用这些数据？</p><h3 id="3-5、用不同的应用层协议对应的软件去解析不同的数据来展示给人类"><a href="#3-5、用不同的应用层协议对应的软件去解析不同的数据来展示给人类" class="headerlink" title="3.5、用不同的应用层协议对应的软件去解析不同的数据来展示给人类"></a>3.5、用不同的应用层协议对应的软件去解析不同的数据来展示给人类</h3><p>比如我们现在是在浏览HTTP的网页，那么需要使用基于HTTP协议开发的Chrome等浏览器去进行数据的解析。我们如果需要收发邮件，那么就需要使用基于POP3、SMTP等协议开发的Outlook等邮件客户端去进行操作。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>上述的过程中，凡是数据<code>发送方</code>都会从最高层的<code>应用层</code>依次往下添加<code>各层的首部信息</code>，最终通过<code>物理传输介质</code>发送出去。凡是数据<code>接收方</code>都会从<code>物理层</code>依次向上进行<code>各层级的信息解析</code>，最终交给对应的<code>应用层进程</code>进行解析展示。如下图所示：</p><p><img src="https://up.eber.vip/Think-Me/img/main/upload/202202171112580.png"></p><p>🌊 这里放出 <a href="http://www.52im.net/?fromuid=26045">即时通讯网</a> 整理的 <a href="https://axhsnkdv56py.compat.objectstorage.us-phoenix-1.oraclecloud.com/bucket-oss/2022/02/202202171129600.png">TCP&#x2F;IP协议图</a> ，我认为是全网总结的最好的协议图。推荐开发者朋友们都下载看看。</p>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OSI </tag>
            
            <tag> TCP/IP </tag>
            
            <tag> 互联网协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针漫谈</title>
      <link href="/post/2022/02/02/5147/"/>
      <url>/post/2022/02/02/5147/</url>
      
        <content type="html"><![CDATA[<h1 id="🧨🧧🧨🧧🧨：首先祝大家新年快乐！"><a href="#🧨🧧🧨🧧🧨：首先祝大家新年快乐！" class="headerlink" title="🧨🧧🧨🧧🧨：首先祝大家新年快乐！"></a>🧨🧧🧨🧧🧨：首先祝大家新年快乐！</h1><h2 id="一、什么是指针（Pointer）"><a href="#一、什么是指针（Pointer）" class="headerlink" title="一、什么是指针（Pointer）"></a>一、什么是指针（Pointer）</h2><p>在计算机科学中，<strong>指针</strong>（英语：Pointer），是编程语言中的一类数据类型及其对象或变量，用来表示或存储一个存储器地址，这个地址的值直接指向（points to）存在该地址的对象的值。【 <a href="https://zh.wikipedia.org/zh-cn/%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)">维基百科</a> 】</p><h2 id="二、我理解的指针"><a href="#二、我理解的指针" class="headerlink" title="二、我理解的指针"></a>二、我理解的指针</h2><p>了解磁盘系统的同学可能听说过inode这个东西（<a href="https://www.eber.vip/ops/28.html">这里具体讲了inode</a>）,它是Unix文件系统中用来储存文件元信息的东西。</p><p>在文件系统中，每个文件对象都对应着一个 inode，其中存储着常用的一些信息（所有者、创建时间、修改时间、文件权限、对应文件对象在系统中存储块的位置等等）<br>操作系统访问一个文件时分为三个步骤：</p><ul><li><p>通过文件名找到对应的 inode 编号</p></li><li><p>通过 inode 编号访问对应文件对象的元信息</p></li><li><p>根据元信息找到文件对应的扇区下对应的数据块，读取数据</p></li></ul><p>🪜 当然了这是简化的流程，实际读取文件比这个复杂一些。还会涉及到内核调用和页缓存等其他操作。</p><p>从这个例子可以发现inode像是一种索引，并且会记录用来指向实际的存储数据块的地址。</p><p>🍺 这里是不是发现有点像指针了。</p><h2 id="三、从Java和Go的角度看指针"><a href="#三、从Java和Go的角度看指针" class="headerlink" title="三、从Java和Go的角度看指针"></a>三、从Java和Go的角度看指针</h2><p>1、众所周知Java语言是没有<strong>“指针”</strong>的。Java虽没有切实的指针类型，但是这个东西是切实存在的。比如Java的引用类型（除了八种基本类型外都是引用类型）实际在存储时都是把<strong>引用</strong>(堆上的地址)储存在栈，<strong>值</strong>(对象的数据)储存在堆中。然后通过引用的指向来进行对象数据的读取。（🔥是不是inode指向数据块的思维）</p><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// 这里实际上就是在栈中放进去一个dog(引用)，然后在堆中开辟了一块空间用来供dog存东西。</span></span><br><span class="line">      dog.name = <span class="string">&quot;库奇&quot;</span>; <span class="comment">// 这时就可以拿着dog存的地址去堆里面给age和name赋值</span></span><br><span class="line">        dog.age = <span class="number">1</span>; <span class="comment">// 其实整个可以理解成文件系统中 dog.mp4 ---&gt; 实际的mp4数据 （不太恰当，能理解就行）</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 这个时候还可以测试一下Java中的值传递是什么逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1. name:&quot;</span> + dog.name + <span class="string">&quot; age:&quot;</span> + dog.age);</span><br><span class="line">      <span class="comment">// 打印结果：1. name:库奇 age:1</span></span><br><span class="line">        change(dog);</span><br><span class="line">        System.out.println(<span class="string">&quot;2. name:&quot;</span> + dog.name + <span class="string">&quot; age:&quot;</span> + dog.age);</span><br><span class="line">      <span class="comment">// 打印结果：2. name:阿奇 age:2</span></span><br><span class="line">      <span class="comment">// 程序成功运行，中途不会报错。</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        dog.age = <span class="number">2</span>;</span><br><span class="line">        dog.name = <span class="string">&quot;阿奇&quot;</span>;</span><br><span class="line">      dog = <span class="literal">null</span>; <span class="comment">// 这一行在idea中你会发现有&quot;The value null assigned to &#x27;dog&#x27; is never used&quot;提示</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可见这里面的值传递并不是传递dog本身过去，而是把dog这个引用复制了一份传给change方法。然后change方法拿到引用去找到堆里面的数据进行修改（修改堆数据肯定会影响dog最后的输出），然后dog &#x3D; null只是把克隆的这个dog引用地址给置空了，完全不影响原dog引用指向堆中。</p><p>2、博主也会Go语言，在Go语言中是有指针这个东西的。他是切实存在的类型。Go的世界中new出来的都是<strong>指针</strong>（Java中new出来的都是<strong>“引用”</strong>）。这里和Java最大的区别就是Go语言的函数是可以将指针作为参数传入，也可以将引用作为参数传入。看来起比Java更加灵活了。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">dog := Dog&#123;</span><br><span class="line">name: <span class="string">&quot;库奇&quot;</span>,</span><br><span class="line">age:  <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;地址:%p 1 name:%s age:%d \n&quot;</span>, &amp;dog, dog.name, dog.age)</span><br><span class="line">  <span class="comment">// 输出：地址:0xc0000a4018 1 name:库奇 age:1</span></span><br><span class="line">change1(dog)</span><br><span class="line">fmt.Printf(<span class="string">&quot;地址:%p 1 name:%s age:%d \n&quot;</span>, &amp;dog, dog.name, dog.age)</span><br><span class="line">  <span class="comment">// 输出：地址:0xc0000a4018 1 name:库奇 age:1</span></span><br><span class="line">change2(&amp;dog)</span><br><span class="line">fmt.Printf(<span class="string">&quot;地址:%p 1 name:%s age:%d \n&quot;</span>, &amp;dog, dog.name, dog.age)</span><br><span class="line">  <span class="comment">// 输出：地址:0xc0000a4018 1 name:路玛 age:3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change1</span><span class="params">(dog Dog)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;change1中dog地址:%p \n&quot;</span>, &amp;dog)</span><br><span class="line">  <span class="comment">// 输出：change1中dog地址:0xc0000a4030</span></span><br><span class="line">dog.name = <span class="string">&quot;阿奇&quot;</span></span><br><span class="line">dog.age = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change2</span><span class="params">(dog *Dog)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;change2中参数指针的地址:%p \n&quot;</span>, dog)</span><br><span class="line">  <span class="comment">// 输出：change2中参数指针的地址:0xc0000a4018</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;change2中参数指针变量的指针地址:%p \n&quot;</span>, &amp;dog)</span><br><span class="line">  <span class="comment">// 输出：change2中参数指针变量的指针地址:0xc0000ac020</span></span><br><span class="line">dog.name = <span class="string">&quot;路玛&quot;</span></span><br><span class="line">dog.age = <span class="number">3</span></span><br><span class="line">  dog = <span class="literal">nil</span> <span class="comment">// 此处把指针变量dog的值置空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>由上面的示例可以发现change1中的参数(dog Dog)实际上就是main中dog的复制品。所以他的内存地址(0xc0000a4030)和main中dog的内存地址(0xc0000a4018)不一致。所以在change1中进行的所有修改都是针对dog(0xc0000a4030)的修改，与main方法的中dog变量没有任何关系。</strong></p><p><strong>而change2中的参数是指针类型，它相当于使用了一个指针参数(dog *Dog)来接收0xc0000a4018的值(⚠️ 这里的dog的值是0xc0000a4018，而dog自己又是一个变量所以他自己也有内存地址0xc0000ac020)。所以后续对name和age的操作实际上是针对0xc0000a4018指向的name和age进行操作，与它本身指针变量没有关系。指针变量只有一个属性那就是地址值(0xc0000a4018)，这时<code>dog = nil</code>其实是修改了指针变量dog的值(0xc0000a4018)为nil，与main中的dog变量没有关系。所以最后调用change2后依旧输出的是<code>地址:0xc0000a4018 1 name:路玛 age:3</code>。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 开发与测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Golang </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何防止IP被恶意解析</title>
      <link href="/post/2022/01/23/28817/"/>
      <url>/post/2022/01/23/28817/</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是恶意解析？有什么影响？"><a href="#一、什么是恶意解析？有什么影响？" class="headerlink" title="一、什么是恶意解析？有什么影响？"></a>一、什么是恶意解析？有什么影响？</h3><p>1.1、恶意解析：如果能直接通过主机IP访问某个网站服务，那么无需服务器管理者的许可任意一个域名解析到此IP也将能访问到该网站服务。</p><p>1.2、造成的影响：</p><ul><li><p>针对国内政策来说，如果是一个未备案的域名解析到你的服务器上并且被工信部或者云服务商扫描到将会触发警告或者关闭网站甚至服务商会关停该服务器资源。</p></li><li><p>如果恶意域名被搜索引擎拉黑或惩罚过，那么被恶意指向的正规网站在搜索引擎的排名将会下降或者拉黑。</p></li><li><p>如果是高权重域名恶意解析到你这里，那么你相当于在帮助他利用你站点的内容增长他域名的收录量。</p></li><li><p>如果被有心的人利用，恶意解析过来之后你的网站可能会有大规模的流量攻击。</p></li></ul><h3 id="二、防范手段（nginx）"><a href="#二、防范手段（nginx）" class="headerlink" title="二、防范手段（nginx）"></a>二、防范手段（nginx）</h3><p>由上述可知恶意解析的根源在于：你的某个网站服务可以直接通过IP访问到。</p><p>所以我们需要禁止通过IP访问到web服务：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line">  <span class="attribute">server_name</span> _;</span><br><span class="line">  <span class="attribute">return</span> <span class="number">444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将nginx的配置文件中默认的server块修改为上面的配置即可。</p><p>这个server块将会添加一个不符合已有的vhost的默认处理逻辑：如果已配置的vhost都没有被匹配到，那么就直接<code>return 444</code>服务端将立刻关闭连接。</p><p>🤔 <strong><mark class="hl-label pink">为什么是444？</mark> </strong></p><p>这里的444其实是nginx内置的错误代码。该代码将立刻关闭连接，不做出任何响应。对于浏览器来说就好像不存在该服务一样。所以返回444比404、403等http code更好。</p><p>⚠️ <strong>这里只讲一下nginx的处理方式。【其他web服务器原理一致，具体做法请上网搜索】</strong></p>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenVPN客户端路由策略配置</title>
      <link href="/post/2022/01/16/1163/"/>
      <url>/post/2022/01/16/1163/</url>
      
        <content type="html"><![CDATA[<p><strong>OpenVPN的路由策略可以在客户端配置，也可以在服务端配置。不过个人不推荐在服务端配置，这样会比较限制用户使用的灵活性。所以本文只讲客户端配置路由策略的方式</strong>。</p><p>先贴一下默认的demo.ovpn部分配置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client</span><br><span class="line">dev tun</span><br><span class="line">proto udp</span><br><span class="line">remote 1.1.1.1 1194</span><br><span class="line">resolv-retry infinite</span><br><span class="line">nobind</span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line">remote-cert-tls server</span><br><span class="line">auth SHA512</span><br><span class="line">cipher AES-256-CBC</span><br><span class="line">ignore-unknown-option block-outside-dns</span><br><span class="line">block-outside-dns</span><br><span class="line">verb 3</span><br><span class="line"></span><br><span class="line"># 证书略</span><br></pre></td></tr></table></figure><p><strong>下面是几个比较重要的点</strong></p><ul><li>🚀 当我们需要自定义路由策略的时候需要添加<code>route-nopull</code>拒绝服务端push的策略。</li><li>🚨<code>block-outside-dns</code>配置项会阻止tap&#x2F;tun以外的所有网络接口的DNS请求，会影响规则外的网站访问，所以需要删除此配置项。</li><li>⚠️默认可写入100条路由规则，如果不够用则使用<code>max-routes 1000</code>定义为最大1000条甚至更多，看个人需求。</li><li>🚩<code>vpn_gateway</code>和<code>net_gateway</code>是相反的策略，前者表示：默认走本地网络，指定的规则会走openvpn；后者表示：默认走openvpn，指定规则走本地网络。</li><li>🌈配置示例：<code>route 10.0.0.0 255.255.240.0 vpn_gateway</code>或者<code>route 10.0.0.0 255.255.240.0 net_gateway</code></li></ul><p>修改之后的配置文件大概是下面这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client</span><br><span class="line">dev tun</span><br><span class="line">proto udp</span><br><span class="line">route-nopull</span><br><span class="line">route 10.0.0.0 255.255.240.0 vpn_gateway # 按照自己实际需求添加子网</span><br><span class="line">route 60.12.0.0 255.255.0.0 vpn_gateway # 我这里只有两条自定义规则所以无需配置max-routes</span><br><span class="line">remote 1.1.1.1 1194 # 按照自己的服务端IP和端口进行配置【可为域名或IP】</span><br><span class="line">resolv-retry infinite</span><br><span class="line">nobind</span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line">remote-cert-tls server</span><br><span class="line">auth SHA512</span><br><span class="line">cipher AES-256-CBC</span><br><span class="line">ignore-unknown-option block-outside-dns</span><br><span class="line"># block-outside-dns # 此项需要被注释掉或者直接删除即可</span><br><span class="line">verb 3</span><br><span class="line"></span><br><span class="line"># 证书略</span><br></pre></td></tr></table></figure><p>⛄在Windows上如果使用OpenVPN GUI客户端可以直接右键进行修改连接的配置文件。也推荐在Windows上面使用 <a href="https://swupdate.openvpn.org/community/releases/OpenVPN-2.5.5-I602-amd64.msi">OpenVPN GUI</a> 体验上更好。</p><p>⛄在Mac OS上使用 <a href="https://tunnelblick.net/release/Tunnelblick_3.8.7a_build_5770.dmg">Tunnelblick</a> 或者 <a href="https://openvpn.net/downloads/openvpn-connect-v3-macos.dmg">OpenVPN官方客户端</a> 体验上个人感觉都差不多。</p>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenVPN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用PicGo打造个人图床</title>
      <link href="/post/2022/01/11/54619/"/>
      <url>/post/2022/01/11/54619/</url>
      
        <content type="html"><![CDATA[<mark class="hl-label pink">向开源致敬！！！</mark> <h3 id="1、PicGo简介"><a href="#1、PicGo简介" class="headerlink" title="1、PicGo简介"></a>1、PicGo简介</h3><p>项目地址：<a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p><p>作者对于PicGo的简介：一个用于快速上传图片并获取图片 URL 链接的工具</p><p>支持的储存厂家：【下表为默认，且作者不再打算支持新的厂家，不过支持安装插件】</p><table><thead><tr><th>厂商</th><th align="left">最低版本</th></tr></thead><tbody><tr><td>七牛云 云储存 (S3类型)</td><td align="left">v1.0</td></tr><tr><td>腾讯云 COS v4&#x2F;v5 (S3类型)</td><td align="left">v1.1 &#x2F; v1.5.0</td></tr><tr><td>阿里云 OSS (S3类型)</td><td align="left">v1.6.0</td></tr><tr><td>又拍云 云储存 (S3类型)</td><td align="left">v1.2.0</td></tr><tr><td>GitHub 仓库 (类似代码提交)</td><td align="left">v1.5.0</td></tr><tr><td>SM.MS V2 (没用过)</td><td align="left">v2.3.0-beta.0</td></tr><tr><td>Imgur (没用过)</td><td align="left">v1.6.0</td></tr></tbody></table><h3 id="2、PicGo安装"><a href="#2、PicGo安装" class="headerlink" title="2、PicGo安装"></a>2、PicGo安装</h3><p>直接<a href="https://github.com/Molunerfinn/PicGo/releases">点击此处</a>进入releases界面选择合适的版本以及合适的系统安装包进行下载安装即可。</p><h3 id="3、插件安装"><a href="#3、插件安装" class="headerlink" title="3、插件安装"></a>3、插件安装</h3><p>因为默认不支持AWS S3(含各厂家衍生版)的储存接入而我这里想接入Oracle Cloud的对象储存，所以就需要去找一个可以接入基于S3通用类型的插件。</p><p>⚠️ Oracle Cloud的对象储存是S3 Signature V4类型</p><p>直接在软件的插件设置界面搜索 s3</p><p><img src="https://up.eber.vip/Think-Me/img/main/2022/01/20220110183553.png"></p><p>名称为s3的这个插件即可以对接Oracle Cloud，我们直接点击安装即可。</p><h3 id="4、插件设置"><a href="#4、插件设置" class="headerlink" title="4、插件设置"></a>4、插件设置</h3><p>安装完成后图床设置下拉菜单会显示Amazon S3的子菜单【如果没有则进入PicGo设置开启显示】</p><p><img src="https://up.eber.vip/Think-Me/img/main/2022/01/20220110184623.png"></p><ul><li><p><strong>S3应用密钥：</strong></p><p>1、在Oracle Cloud控制台如图所示找到用户设置</p><p><img src="https://up.eber.vip/Think-Me/img/main/2022/01/20220111110812.png"></p><p>2、客户密钥-访问密钥 即为这里的应用密钥ID【如果之前没有创建过，就先看下一步生成密钥，然后在过来复制访问密钥】</p><p><img src="https://up.eber.vip/Think-Me/img/main/2022/01/20220111111017.png"></p></li><li><p><strong>应用密钥：</strong></p><p>在上一步客户密钥那里点击生成密钥，随便输入一个名字然后生成即可，注意这里的密钥只显示一次，请妥善保存，如果丢失就只能删除后重新创建一个。【这里的密钥和上面的访问密钥要是同一条记录】</p><p><img src="https://up.eber.vip/Think-Me/img/main/2022/01/20220111111217.png"></p></li><li><p><strong>桶名称和权限这俩比较简单，都是创建储存桶时定义的，这里重点介绍一下自定义节点的这个URL是如何获取的：</strong></p><p>1、首先我们在控制台进入到储存桶界面，然后随便上传一个小文件。</p><p><img src="https://up.eber.vip/Think-Me/img/main/2022/01/20220111112340.png"></p><p>这里查看对象详细信息里面有个URL路径，比如我这个是<code>https://objectstorage.us-phoenix-1.oraclecloud.com/n/axhsnkdv56py/b/bucket-oss/o/111.pdf</code> 我们取链接的 <code>objectstorage.us-phoenix-1.oraclecloud.com</code> 域名这一部分【同一个区域下这个域名是相同的】然后再这个域名前面拼上自己的桶名称空间和compat 格式应该是这样的 <code>桶名称空间.compat.objectstorage.us-phoenix-1.oraclecloud.com</code> 这里的桶名称空间在储存桶信息里面可以找到。</p><p><img src="https://up.eber.vip/Think-Me/img/main/2022/01/20220111112823.png"></p><p>那么我这个最终拼出来的自定义节点就是 <code>https://axhsxxxx56py.compat.objectstorage.us-phoenix-1.oraclecloud.com</code></p></li><li><p><strong>自定义域名：</strong></p><p>1、首先获取到我们要301或302的目标链接</p><p><img src="https://up.eber.vip/Think-Me/img/main/2022/01/20220111113756.png"></p><p>依旧是随便打开一个文件的对象相信信息找到URL路径，我这边是<code>https://objectstorage.us-phoenix-1.oraclecloud.com/n/axhsnkdv56py/b/bucket-oss/o/111.pdf</code></p><p>我们需要用301或302的方式去实现自定义域名访问文件，那么肯定是要把我们的子域名比如<code>s3.eber.vip</code> 替代掉文件名之前的链接，也就是<code>https://objectstorage.us-phoenix-1.oraclecloud.com/n/axhsnkdv56py/b/bucket-oss/o</code></p><p>2、有了链接，那么直接拼上请求的文件名即可，所以我们可以使用nginx去配置301或者302的跳转</p><p>首先我们要把<code>s3.eber.vip</code>解析到我们nginx所在的服务器IP上，然后在nginx中创建一个s3.eber.vip.conf配置文件【主配置文件需要引入该文件，否则不生效】。</p><p>我的配置文件如下：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">  <span class="attribute">listen</span> [::]:<span class="number">80</span>;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">443</span> ssl http2;</span><br><span class="line">  <span class="attribute">listen</span> [::]:<span class="number">443</span> ssl http2;</span><br><span class="line">  <span class="attribute">ssl_certificate</span> /usr/local/nginx/conf/ssl/s3.eber.vip.crt;</span><br><span class="line">  <span class="attribute">ssl_certificate_key</span> /usr/local/nginx/conf/ssl/s3.eber.vip.key;</span><br><span class="line">  <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">  <span class="attribute">ssl_ciphers</span> TLS13-AES-<span class="number">256</span>-GCM-SHA384:TLS13-CHACHA20-POLY1305-SHA256:TLS13-AES-<span class="number">128</span>-GCM-SHA256:TLS13-AES-<span class="number">128</span>-CCM-<span class="number">8</span>-SHA256:TLS13-AES-<span class="number">128</span>-CCM-SHA256:EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br><span class="line">  <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">  <span class="attribute">ssl_session_timeout</span> <span class="number">10m</span>;</span><br><span class="line">  <span class="attribute">ssl_session_cache</span> builtin:<span class="number">1000</span> shared:SSL:<span class="number">10m</span>;</span><br><span class="line">  <span class="attribute">ssl_buffer_size</span> <span class="number">1400</span>;</span><br><span class="line">  <span class="attribute">add_header</span> Strict-Transport-Security max-age=<span class="number">15768000</span>;</span><br><span class="line">  <span class="attribute">ssl_stapling</span> <span class="literal">on</span>;</span><br><span class="line">  <span class="attribute">ssl_stapling_verify</span> <span class="literal">on</span>;</span><br><span class="line">  <span class="attribute">server_name</span> s3.eber.vip;</span><br><span class="line">  <span class="attribute">access_log</span> /data/wwwlogs/s3.eber.vip_nginx.log combined;</span><br><span class="line">  <span class="attribute">index</span> index.html index.htm index.php;</span><br><span class="line">  <span class="attribute">root</span> /data/wwwroot/s3.eber.vip;</span><br><span class="line">  <span class="attribute">if</span> (<span class="variable">$ssl_protocol</span> = <span class="string">&quot;&quot;</span>) &#123; <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">302</span> https://objectstorage.us-phoenix-1.oraclecloud.com/n/axhsnkdv56py/b/bucket-oss/o<span class="variable">$request_uri</span>; <span class="comment"># 我这里不想让地址栏变成oracle的一大串链接，所以使用的是302重定向。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>OK！配置相关的教程已经结束，如需要使用教程则直接访问 <a href="https://picgo.github.io/PicGo-Doc/zh/guide/">PicGo官方文档</a> 进行查询。</p>]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PicGo </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用火焰图分析CPU使用情况</title>
      <link href="/post/2022/01/09/47231/"/>
      <url>/post/2022/01/09/47231/</url>
      
        <content type="html"><![CDATA[<h3 id="1、安装Perf性能分析工具"><a href="#1、安装Perf性能分析工具" class="headerlink" title="1、安装Perf性能分析工具"></a>1、安装Perf性能分析工具</h3><p>Perf工具是非常强大的Linux性能分析工具，可以通过该工具获得进程内的调用情况、资源消耗情况并查找分析热点函数。</p><p>所以我们使用perf工具进行性能数据的采集。</p><p>在Ubuntu上，如果不知道perf如何安装的话可以直接执行perf在命令执行报错回显里面会有建议：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# perf</span><br><span class="line"></span><br><span class="line">Command &#x27;perf&#x27; not found, but can be installed with:</span><br><span class="line"></span><br><span class="line">apt install linux-oem-5.6-tools-common  # version 5.6.0-1017.17, or</span><br><span class="line">apt install linux-tools-common          # version 5.4.0-92.103</span><br><span class="line"></span><br><span class="line">root@ubuntu:~# </span><br></pre></td></tr></table></figure><p>这里他建议我们执行<code>apt install linux-oem-5.6-tools-common</code>或者<code>apt install linux-tools-common</code>进行perf的安装。那我们就先执行<code>apt install linux-tools-common</code>安装一下试试。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# apt install linux-tools-common</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">You might want to run &#x27;apt --fix-broken install&#x27; to correct these.</span><br><span class="line">The following packages have unmet dependencies:</span><br><span class="line"> linux-headers-5.4.0-92-generic : Depends: linux-headers-5.4.0-92 but it is not going to be installed</span><br><span class="line"> linux-image-generic : Depends: linux-modules-extra-5.4.0-92-generic but it is not going to be installed</span><br><span class="line">E: Unmet dependencies. Try &#x27;apt --fix-broken install&#x27; with no packages (or specify a solution).</span><br><span class="line">root@ubuntu:~# </span><br></pre></td></tr></table></figure><p>漂亮！报错了！</p><p>不要慌，我们要学会阅读报错信息，不怕它报错，就怕它不报错。</p><p>这里的意思大概是咱们要安装的<code>linux-tools-common</code>需要依赖<code>linux-headers-5.4.0-92-generic</code>和<code>linux-image-generic</code>并且它还给出了建议”You might want to run ‘apt –fix-broken install’ to correct these.”。那我们就按照它说的执行<code>apt --fix-broken install</code>然后再执行<code>linux-tools-common</code>就能成功安装。然后我们执行perf -h看一下。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# perf -h</span><br><span class="line">WARNING: perf not found for kernel 5.4.0-91</span><br><span class="line"></span><br><span class="line">  You may need to install the following packages for this specific kernel:</span><br><span class="line">    linux-tools-5.4.0-91-generic</span><br><span class="line">    linux-cloud-tools-5.4.0-91-generic</span><br><span class="line"></span><br><span class="line">  You may also want to install one of the following packages to keep up to date:</span><br><span class="line">    linux-tools-generic</span><br><span class="line">    linux-cloud-tools-generic</span><br><span class="line">root@ubuntu:~# </span><br></pre></td></tr></table></figure><p>这里它又报个警告信息，这虽说是警告，但是不修复这个警告我们还是无法正常使用perf。<br>所以我们还需要安装linux-tools-5.4.0-91-generic和linux-tools-generic</p><p>一样的执行<code>apt install linux-tools-5.4.0-91-generic</code>和<code>linux-tools-generic</code></p><p>⚠️：你的内核版本可能和我的不同，不要盲目复制！所以比较推荐使用<code>apt install linux-tools-`uname -r` </code>进行安装。</p><p>现在我们再执行<code>perf -h</code>看看</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# perf -h</span><br><span class="line"></span><br><span class="line"> usage: perf [--version] [--help] [OPTIONS] COMMAND [ARGS]</span><br><span class="line"></span><br><span class="line"> The most commonly used perf commands are:</span><br><span class="line">   annotate        Read perf.data (created by perf record) and display annotated code</span><br><span class="line">   archive         Create archive with object files with build-ids found in perf.data file</span><br><span class="line">   bench           General framework for benchmark suites</span><br><span class="line">   buildid-cache   Manage build-id cache.</span><br><span class="line">   buildid-list    List the buildids in a perf.data file</span><br><span class="line">   c2c             Shared Data C2C/HITM Analyzer.</span><br><span class="line">   config          Get and set variables in a configuration file.</span><br><span class="line">   data            Data file related processing</span><br><span class="line">   diff            Read perf.data files and display the differential profile</span><br><span class="line">   evlist          List the event names in a perf.data file</span><br><span class="line">   ftrace          simple wrapper for kernel&#x27;s ftrace functionality</span><br><span class="line">   inject          Filter to augment the events stream with additional information</span><br><span class="line">   kallsyms        Searches running kernel for symbols</span><br><span class="line">   kmem            Tool to trace/measure kernel memory properties</span><br><span class="line">   kvm             Tool to trace/measure kvm guest os</span><br><span class="line">   list            List all symbolic event types</span><br><span class="line">   lock            Analyze lock events</span><br><span class="line">   mem             Profile memory accesses</span><br><span class="line">   record          Run a command and record its profile into perf.data</span><br><span class="line">   report          Read perf.data (created by perf record) and display the profile</span><br><span class="line">   sched           Tool to trace/measure scheduler properties (latencies)</span><br><span class="line">   script          Read perf.data (created by perf record) and display trace output</span><br><span class="line">   stat            Run a command and gather performance counter statistics</span><br><span class="line">   test            Runs sanity tests.</span><br><span class="line">   timechart       Tool to visualize total system behavior during a workload</span><br><span class="line">   top             System profiling tool.</span><br><span class="line">   version         display the version of perf binary</span><br><span class="line">   probe           Define new dynamic tracepoints</span><br><span class="line">   trace           strace inspired tool</span><br><span class="line"></span><br><span class="line"> See &#x27;perf help COMMAND&#x27; for more information on a specific command.</span><br><span class="line"></span><br><span class="line">root@ubuntu:~# </span><br></pre></td></tr></table></figure><p>OK，安装成功！</p><h3 id="2、使用Perf进行性能统计"><a href="#2、使用Perf进行性能统计" class="headerlink" title="2、使用Perf进行性能统计"></a>2、使用Perf进行性能统计</h3><p>使用之前我们先了解一下Perf都能统计哪些东西的性能数据。通过上面的<code>perf -h</code> 发现<code>list</code> 参数是可以列出所有event type。(List all symbolic event types。)<br>那我们执行<code>perf list</code>会发现列出的有Hardware event、Software event、Tool event、Hardware cache event这些（大致里面就是缓存命中、cpu时间、L1缓存命中等一大堆指标）</p><p>比如说我现在需要监测resource-page-1.0.0.jar这个java服务器运行期间的CPU使用时间、上下文切换次数等信息。</p><p>同样从帮助文档中得知<code>stat            Run a command and gather performance counter statistics</code>stat这个参数的功能大致意思是运行命令并收集性能计数器统计信息。</p><p>我们先直接执行<code>perf stat java -jar resource-page-1.0.0.jar</code>，这个时候java服务器就开始运行了，然后把该java服务的测试流程走一遍，最后直接Ctrl + C结束掉当前任务。这时终端就会回显统计信息：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Performance counter stats for &#x27;java -jar resource-page-1.0.0.jar&#x27;:</span><br><span class="line"></span><br><span class="line">        15,710.07 msec task-clock                #    0.263 CPUs utilized          </span><br><span class="line">           11,808      context-switches          #    0.752 K/sec                  </span><br><span class="line">              584      cpu-migrations            #    0.037 K/sec                  </span><br><span class="line">          131,695      page-faults               #    0.008 M/sec                  </span><br><span class="line">   40,742,785,521      cycles                    #    2.593 GHz                    </span><br><span class="line">   46,422,658,743      instructions              #    1.14  insn per cycle         </span><br><span class="line">    9,177,132,057      branches                  #  584.156 M/sec                  </span><br><span class="line">      289,552,283      branch-misses             #    3.16% of all branches        </span><br><span class="line"></span><br><span class="line">     59.795222167 seconds time elapsed</span><br><span class="line"></span><br><span class="line">     14.154782000 seconds user</span><br><span class="line">      2.164583000 seconds sys</span><br></pre></td></tr></table></figure><p>我们会发现这种监测只是在终端回显这些数据并没有什么数据留存下来供我们生成火焰图，所以我们接下来要使用<code>record          Run a command and record its profile into perf.data</code>record这个参数来把收集来的数据保存到perf.data文件中。</p><p>那首先我们先将java服务启动并获取到该服务器的pid。（我这里是2403020后续我们会用到这个pid）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# ps -ef|grep java</span><br><span class="line">root     2403020       1  0 16:25 pts/1    00:00:18 java -jar /usr/local/app/resource/resource-page-1.0.0.jar 1000</span><br><span class="line">root     2406162 2354230  0 17:03 pts/1    00:00:00 grep --color=auto java</span><br><span class="line">root@ubuntu:~#</span><br></pre></td></tr></table></figure><p>然后我们使用<code>perf record -F 50 -a -p 2403020 -g -- sleep 60</code>来采集数据。需要等待60s。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# perf record -F 50 -a -p 2403020 -g -- sleep 60</span><br><span class="line">[ perf record: Woken up 1 times to write data ]</span><br><span class="line">[ perf record: Captured and wrote 0.064 MB perf.data (1117 samples) ]</span><br><span class="line">root@ubuntu:~#</span><br></pre></td></tr></table></figure><p>解释一下：所有的参数和用法可以执行<code>perf record -h</code>查看。这里我就解释一下我上面用到几个参数：</p><p>-F 50：每秒采样50次</p><p>-a：来自系统范围所有CPU的采集</p><p>-p：记录调用栈</p><p>-p：绑定进程的PID，这样就能针对某个进程进行监控。</p><p>– sleep 60：监控持续时间60秒</p><h3 id="3、生成火焰图"><a href="#3、生成火焰图" class="headerlink" title="3、生成火焰图"></a>3、生成火焰图</h3><p>上述操作后文件夹中将会多出来一个叫perf.data的文件，但这个文件还不能直接生成火焰图，这时我们需要转换一下。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# perf script &gt; out.perf</span><br><span class="line">root@ubuntu:~# ll</span><br><span class="line">total 31596</span><br><span class="line">drwxr-xr-x 3 root root     4096 Jan  7 17:43 ./</span><br><span class="line">drwxr-xr-x 3 root root     4096 Dec  6 17:51 ../</span><br><span class="line">drwxr-xr-x 2 root root     4096 Jan  7 04:52 logs/</span><br><span class="line">-rw------- 1 root root     4054 Jan  7 16:19 nohup.out</span><br><span class="line">-rw-r--r-- 1 root root    37015 Jan  7 17:43 out.perf</span><br><span class="line">-rw------- 1 root root    48268 Jan  7 17:43 perf.data</span><br><span class="line">-rwxr-xr-x 1 root root 32243563 Dec 13 13:10 resource-page-1.0.0.jar*</span><br><span class="line">-rwxr-xr-x 1 root root     1564 Dec  6 17:53 start.sh*</span><br><span class="line">root@ubuntu:~#</span><br></pre></td></tr></table></figure><p>然后利用FlameGraph项目进行火焰图的生成：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# git clone --depth 1 https://github.com/brendangregg/FlameGraph.git</span><br><span class="line">root@ubuntu:~# FlameGraph/stackcollapse-perf.pl out.perf &gt; out.folded</span><br><span class="line">root@ubuntu:~# FlameGraph/flamegraph.pl out.folded &gt; out.svg</span><br></pre></td></tr></table></figure><p>🪜：如果生成火焰图的时候提示  <font color=red>ERROR: No stack counts found</font> 一般有三种情况</p><p>第一种情况：监控时间太短，这种情况稍微调大sleep的时间即可。</p><p>第二种情况：程序没有在运行了，这种情况就需要排查一下被监控程序的运行情况。</p><p>第三种情况：就是我这种，我这边测试用的是一个java web程序，所以在监控期间最好是请求几次接口。</p><p>一切顺利的话当前文件夹中就会出现一个svg图片，这个图片打开就是火焰图，效果如图：</p><ul><li>java程序的这个因为只有我手动调用了几次逻辑简单的接口可能火焰效果不明显[调用栈越深火焰越高，CPU耗时越长火焰越宽]</li></ul><p><img src="https://up.eber.vip/Think-Me/img/main/2022/01/20220110174720.png"></p>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Perf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticsSearch伪集群搭建</title>
      <link href="/post/2022/01/01/47360/"/>
      <url>/post/2022/01/01/47360/</url>
      
        <content type="html"><![CDATA[<p><strong>⚠️⚠️⚠️该教程基于docker- compose建立伪集群，仅适用于开发和测试中使用</strong></p><h3 id="1、建立项目目录及各配置文件。"><a href="#1、建立项目目录及各配置文件。" class="headerlink" title="1、建立项目目录及各配置文件。"></a>1、建立项目目录及各配置文件。</h3><ul><li>首先创建一些需要映射的目录：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# mkdir -p es/data</span><br><span class="line">root@ubuntu:~# mkdir -p es/logs</span><br><span class="line">root@ubuntu:~# ll es/</span><br><span class="line">total 16</span><br><span class="line">drwxr-xr-x 4 root root 4096 Jan 10 02:25 ./</span><br><span class="line">drwxr-xr-x 4 root root 4096 Jan 10 02:25 ../</span><br><span class="line">drwxr-xr-x 2 root root 4096 Jan 10 02:25 data/</span><br><span class="line">drwxr-xr-x 2 root root 4096 Jan 10 02:25 logs/</span><br><span class="line">root@ubuntu:~#</span><br></pre></td></tr></table></figure></li><li>然后创建docker-compose.yml配置文件<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">es_node0:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">elasticsearch:7.16.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es_node0</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms1g -Xmx1g&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$PWD/es_node0.yml:/usr/share/elasticsearch/config/elasticsearch.yml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$PWD/data/node0:/usr/share/elasticsearch/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$PWD/logs/node0:/usr/share/elasticsearch/logs</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">29200</span><span class="string">:9200</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">29300</span><span class="string">:9300</span></span><br><span class="line">  <span class="attr">es_node1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">elasticsearch:7.16.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es_node1</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms1g -Xmx1g&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$PWD/es_node1.yml:/usr/share/elasticsearch/config/elasticsearch.yml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$PWD/data/node1:/usr/share/elasticsearch/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$PWD/logs/node1:/usr/share/elasticsearch/logs</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">29201</span><span class="string">:9200</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">29301</span><span class="string">:9301</span></span><br><span class="line">  <span class="attr">es_node2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">elasticsearch:7.16.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es_node2</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms1g -Xmx1g&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$PWD/es_node2.yml:/usr/share/elasticsearch/config/elasticsearch.yml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$PWD/data/node2:/usr/share/elasticsearch/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$PWD/logs/node2:/usr/share/elasticsearch/logs</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">29202</span><span class="string">:9200</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">29302</span><span class="string">:9302</span></span><br><span class="line">  <span class="attr">kibana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">kibana:7.16.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kibana</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SERVER_NAME=kibana</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ELASTICSEARCH_HOSTS=[&quot;http://es_node0:9200&quot;,&quot;http://es_node1:9201&quot;,&quot;http://es_node2:9202&quot;]</span>      </span><br><span class="line">      <span class="bullet">-</span> <span class="string">XPACK_MONITORING_ENABLED=true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">25601</span><span class="string">:5601</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">es_node0</span></span><br></pre></td></tr></table></figure></li></ul><p>⚠️：因为我的防火墙限制这台机器仅20000-30000端口能开放，所以我的容器端口映射出来都是20000+的端口，你们按照自己的实际情况去配置即可。</p><ul><li><p>node0的配置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 集群名称，三个节点要一致</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">es-cluster</span></span><br><span class="line"><span class="comment"># 当前节点名称</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node0</span></span><br><span class="line"><span class="comment"># 是否有资格作为主节点</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 是否存储数据</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 最⼤集群节点数</span></span><br><span class="line"><span class="attr">node.max_local_storage_nodes:</span> <span class="number">3</span></span><br><span class="line"><span class="comment"># 监听host</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="comment"># 容器内服务端⼝ 默认9200即可</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="comment"># 内部节点之间通信端⼝</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9300</span></span><br><span class="line"><span class="comment"># es7.x之后新增的配置，写⼊候选主节点的设备地址，在开启服务后可以被选为主节点</span></span><br><span class="line"><span class="attr">discovery.seed_hosts:</span> [<span class="string">&quot;es_node0:9300&quot;</span>,<span class="string">&quot;es_node1:9301&quot;</span>,<span class="string">&quot;es_node2:9302&quot;</span>]</span><br><span class="line"><span class="comment"># es7.x之后新增的配置，初始化集群时需要此配置来选举master，此处的node名称为各节点配置文件中的节点名称</span></span><br><span class="line"><span class="attr">cluster.initial_master_nodes:</span> [<span class="string">&quot;node0&quot;</span>, <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;node2&quot;</span>]</span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http.cors.allow-credentials:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>node1和node2的配置（node1和node2配置基本一致）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 集群名称 三个节点要一致</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">es-cluster</span></span><br><span class="line"><span class="comment"># 当前节点名称</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node1</span></span><br><span class="line"><span class="comment"># 是否有资格作为主节点</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 是否存储数据</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 最⼤集群节点数</span></span><br><span class="line"><span class="attr">node.max_local_storage_nodes:</span> <span class="number">3</span></span><br><span class="line"><span class="comment">#⽹关地址</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="comment"># 端⼝</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9201</span></span><br><span class="line"><span class="comment"># 内部节点之间通信端⼝</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9301</span></span><br><span class="line"><span class="comment"># es7.x之后新增的配置，写⼊候选主节点的设备地址，在开启服务后可以被选为主节点</span></span><br><span class="line"><span class="attr">discovery.seed_hosts:</span> [<span class="string">&quot;es_node0:9300&quot;</span>,<span class="string">&quot;es_node1:9301&quot;</span>,<span class="string">&quot;es_node2:9302&quot;</span>]</span><br><span class="line"><span class="comment"># es7.x之后新增的配置，初始化集群时需要此配置来选举master，此处的node名称为各节点配置文件中的节点名称</span></span><br><span class="line"><span class="attr">cluster.initial_master_nodes:</span> [<span class="string">&quot;node0&quot;</span>, <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;node2&quot;</span>]</span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http.cors.allow-credentials:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2、启动和安装ik分词器"><a href="#2、启动和安装ik分词器" class="headerlink" title="2、启动和安装ik分词器"></a>2、启动和安装ik分词器</h3><ul><li>启动</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><p>教你们一个骚操作：我们这里直接是使用<code>up</code>启动并没有带上<code>-d</code>参数后台启动，这样就不用执行查看日志的命令就可以第一时间直接看见启动日志。什么？ 你问我这样启动之后怎么后台运行？ <strong>直接关掉当前这个终端即可</strong>，这个是我2019年的时候发现的<code>docker-compose</code>与其他持续运行软件的差异。</p><ul><li>安装ik分词器(一共三个容器每次替换掉容器名称&#x2F;容器ID 执行三次即可)<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# docker exec -ti es_node0 ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.16.2/elasticsearch-analysis-ik-7.16.2.zip</span><br><span class="line">root@ubuntu:~# docker restart es_node0</span><br></pre></td></tr></table></figure></li></ul><p>✋：这一步操作实际上可以在Dockerfile中操作。</p><h3 id="3、查询集群状态"><a href="#3、查询集群状态" class="headerlink" title="3、查询集群状态"></a>3、查询集群状态</h3><ul><li>推荐使用Chrome的<a href="https://chrome.google.com/webstore/detail/elasticsearch-head/ffmkiejjmecolpfloofpjologoblkegm?utm_source=chrome-ntp-icon">ElasticSearch Head</a>插件，有条件的可以直接点击跳转到下载页面进行安装。</li><li>没有网络条件的可以<a href="https://up.eber.vip/Think-Me/img/main/2022/01/ElasticSearch_Head_0.1.5.0.crx">点击此处</a>下载然后再手动进行离线安装【一般是打开插件管理的开发者模式然后直接把crx文件拖进去，如果不行请搜索一下教程】。</li></ul><p>插件打开后填入链接地址即可连接ES并展示出状态信息如下所示：<br><img src="https://up.eber.vip/Think-Me/img/main/2022/01/20220110150847.png"></p><h3 id="3、可能遇到的问题"><a href="#3、可能遇到的问题" class="headerlink" title="3、可能遇到的问题"></a>3、可能遇到的问题</h3><p>1、Error opening log file ‘logs&#x2F;gc.log’: Permission denied</p><p>可能会报这种权限不足的情况，这种情况下想简单点就直接<code>chmod -R 777 ./logs</code>将logs目录设置成所有用户可读写即可。</p><p>2、max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</p><p>这个是提示你的内核参数vm.max_map_count设置的过低，直接按照提示修改即可。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# vi /etc/sysctl.conf</span><br><span class="line">vm.max_map_count = 655300 # 文件末尾添加该项保存即可</span><br><span class="line"></span><br><span class="line">root@ubuntu:~# sysctl -p </span><br></pre></td></tr></table></figure><p>内核参数生效后重新启动docker-compose即可。</p>]]></content>
      
      
      <categories>
          
          <category> 开发与测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticsSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两步实现在Ubuntu18,20等高版本设置静态IP</title>
      <link href="/post/2021/12/31/50729/"/>
      <url>/post/2021/12/31/50729/</url>
      
        <content type="html"><![CDATA[<p><strong>新版本的Ubuntu已经放弃了在&#x2F;etc&#x2F;network&#x2F;interfaces里面配置IP，改为在&#x2F;etc&#x2F;netplan&#x2F;00-installer-config.yaml的yaml文件中配置IP地址。</strong></p><h4 id="1-修改配置文件【🎗️注意：不同的云服务器厂商这个yaml的文件名字可能不一样，请注意自己的文件名】"><a href="#1-修改配置文件【🎗️注意：不同的云服务器厂商这个yaml的文件名字可能不一样，请注意自己的文件名】" class="headerlink" title="1. 修改配置文件【🎗️注意：不同的云服务器厂商这个yaml的文件名字可能不一样，请注意自己的文件名】"></a>1. 修改配置文件【🎗️注意：不同的云服务器厂商这个yaml的文件名字可能不一样，请注意自己的文件名】</h4><p>使用熟悉的编辑器打开 &#x2F;etc&#x2F;netplan&#x2F; 下面的yaml配置文件，我的是00-installer-config.yaml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi  /etc/netplan/00-installer-config.yaml </span><br></pre></td></tr></table></figure><p>根据自己的需要配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># This is the network config written by &#x27;subiquity&#x27;</span><br><span class="line">network:</span><br><span class="line">  ethernets:</span><br><span class="line">    enp0s3: # 网卡的名称</span><br><span class="line">      dhcp4: true</span><br><span class="line">    enp0s8:</span><br><span class="line">      addresses: [10.0.0.101/20] # 配置的静态ip地址和掩码 注意单词是addresses</span><br><span class="line">      dhcp4: false # 关闭dhcp4</span><br><span class="line">      optional: true</span><br><span class="line">      gateway4: 10.0.0.1 # 网关地址</span><br><span class="line">  nameservers: # 设置dns</span><br><span class="line">        addresses: [10.0.0.1,8.8.8.8]  # DNS服务器地址，多个DNS服务器地址需要用英文逗号分隔开</span><br><span class="line">  version: 2</span><br></pre></td></tr></table></figure><h4 id="2-使配置生效"><a href="#2-使配置生效" class="headerlink" title="2. 使配置生效"></a>2. 使配置生效</h4><p>执行netplan apply使配置生效</p>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的聊一聊Redis</title>
      <link href="/post/2021/12/29/21421/"/>
      <url>/post/2021/12/29/21421/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Redis雪崩、穿透、并发等问题"><a href="#一、Redis雪崩、穿透、并发等问题" class="headerlink" title="一、Redis雪崩、穿透、并发等问题"></a>一、Redis雪崩、穿透、并发等问题</h2><h3 id="1-1、缓存雪崩"><a href="#1-1、缓存雪崩" class="headerlink" title="1.1、缓存雪崩"></a>1.1、<strong>缓存雪崩</strong></h3><p>缓存雪崩指的是：数据未加载到缓存中或缓存同一时间大规模的失效，所有请求都穿透到数据库。最终可能会导致数据库主机CPU和内存负载过高甚至宕机。</p><p>🌰<strong>举一个雪崩的简单例子：</strong></p><p>1、redis集群大面积故障或数据没有预读到缓存中。</p><p>2、当大量的请求进来后没有命中缓存将直接穿透到数据库，数据库的压力暴增。</p><p>3、如果持续有请求穿透缓存进来，可能很快就会超出数据库当时的设计阈值，直至宕机。</p><p>4、由于大量的应用服务依赖数据库和redis的服务，这个时候很快就会变成各服务集群的雪崩，最后整个服务彻底崩溃。</p><p>⚠️<strong>缓存雪崩解决思路：</strong></p><p>📉<em><strong>1、缓存的高可用</strong></em></p><p>缓存层设计成高可用，防止缓存大面积故障。即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，例如 Redis Sentinel 和 Redis Cluster 都实现了高可用。（官方推荐Redis Sentinel）</p><p>📉<em><strong>2、缓存降级</strong></em></p><p>可以利用ehcache等本地缓存，但主要还是对源服务访问进行限流、资源隔离(熔断)、降级等。</p><p>当访问量剧增、服务出现问题仍然需要保证服务还是可用的。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级，这里会涉及到运维的配合。</p><p>降级的最终目的是保证核心服务可用，即使是有损的。</p><p>比如推荐服务中，很多都是个性化的需求，假如个性化需求不能提供服务了，可以降级补充热点数据，不至于造成前端页面是个大空白。</p><p>在进行降级之前要对系统进行梳理，比如：哪些业务是核心(必须保证)，哪些业务可以容许暂时不提供服务(利用静态页面替换)等，以及配合服务器核心指标，来后设置整体预案，比如：</p><p>normal：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p><p>warning：有些服务在一段时间内成功率有波动(如在95~100%之间)，可以自动降级或人工降级，并发送告警；</p><p>error：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</p><p>emergency：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p><p>📉<em><strong>3、Redis备份恢复和缓存预热</strong></em></p><p>这两点都是解决在<strong>项目第一次启动</strong>或者<strong>缓存故障后冷启动时</strong>缓存中没有任何数据，这时如果是高并发场景下就会出现大量的请求穿透到原始数据库可能导致数据库宕机。</p><p>这种比较尴尬的启动即宕机还是很致命的😄。</p><p>所以在项目启动前需要将redis的数据备份进行恢复，新项目没有备份的情况下可以使用脚本或者程序逻辑先提前将相关的缓存数据直接加载到缓存系统。</p><p>这个是比较简单基础的预热方式，实际生产中可能需要根据以往的日志进行分析按照数据的热度去进行缓存。</p><p>📉<em><strong>4、提前演练，防患于未然</strong></em></p><p>最后，建议还是在项目上线前，模拟测试缓存层宕掉后，应用以及后端的负载情况以及可能出现的问题，对高可用提前模拟测试，提前发现问题。</p><p>⚠️其实最重要的就是这一步：防患于未然，做到心中有数，这样不至于生产环境上出现预料之外的问题而手忙脚乱！</p><h3 id="1-2、缓存穿透"><a href="#1-2、缓存穿透" class="headerlink" title="1.2、缓存穿透"></a>1.2、<strong>缓存穿透</strong></h3><p>缓存穿透指的是：查询的数据本身在数据库中就没有，自然在缓存中也不会有。这样就导致查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过了缓存直接查数据库，这也是经常提的缓存命中率问题。</p><p>⚠️<strong>缓存穿透解决思路：</strong></p><p>1、使用布隆过滤器将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</p><p>2、如果一个查询返回的数据为空，我们仍然把这个空结果进行缓存，设置一个过期时间或者当有值的时候将缓存中的值替换掉即可。通过这个直接设置的默认值放到缓存中，这样第二次到缓存中获取就有值，而不会继续访问数据库，这种方法最简单粗暴且实用。</p><h3 id="1-3、缓存并发"><a href="#1-3、缓存并发" class="headerlink" title="1.3、缓存并发"></a>1.3、<strong>缓存并发</strong></h3><p>这里的并发指的是多个redis的client同时set key引起的并发问题。其实redis自身就是单线程操作，多个client并发操作，按照先到先执行的原则，先到的先执行，其余的阻塞。当然，另外的解决方案是把redis.set操作放在队列中使其串行化，必须的一个一个执行。</p><h2 id="二、Redis为什么是单线程还很快"><a href="#二、Redis为什么是单线程还很快" class="headerlink" title="二、Redis为什么是单线程还很快"></a>二、Redis为什么是单线程还很快</h2><h3 id="2-1、Redis很快的原因"><a href="#2-1、Redis很快的原因" class="headerlink" title="2.1、Redis很快的原因"></a>2.1、Redis很快的原因</h3><p>1.redis是基于内存的，内存的读写速度非常快（普通单通道DDR3 1600MHz内存的理论读写速度在12.8GB&#x2F;s 实际读写在5GB&#x2F;s左右）；</p><p>2.redis是单线程的，省去了很多上下文切换线程的时间（线程切换会频繁的记录寄存器的存储和程序计数器存储的指令内容）；</p><p>3.redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。</p><p>下面重点介绍单线程设计和IO多路复用核心设计快的原因。</p><h3 id="2-2、为什么Redis是单线程的？"><a href="#2-2、为什么Redis是单线程的？" class="headerlink" title="2.2、为什么Redis是单线程的？"></a>2.2、为什么Redis是单线程的？</h3><p>官方说明之前，我先说一下针对现代计算机的工作特点，前人总结的程序设计思路：</p><p><strong>高并发，低耗时的情况，建议少线程。<br>低并发，高耗时的情况：建议多线程。<br>高并发高耗时，要分析任务类型、增加排队、加大线程数。</strong></p><p>1.官方答案</p><p>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p><p>2.性能指标</p><p>关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p><p>3.详细原因</p><p>1)不需要各种锁的性能消耗</p><p>Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除</p><p>一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。</p><p>总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</p><p>2)单线程多进程集群方案</p><p>单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。</p><p>所以单线程、多进程的集群不失为一个好的解决方案。</p><p>3)CPU消耗</p><p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</p><p>但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？</p><p>可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。</p><p>Redis单线程的优劣势</p><p>单进程单线程优势代码更清晰，处理逻辑更简单不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗不存在多进程或者多线程导致的切换而消耗CPU</p><p>单进程单线程弊端无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；</p><p>IO多路复用技术</p><p>redis 采用网络IO多路复用技术来保证在多连接的时候， 系统的高吞吐量。</p><p>多路-指的是多个socket连接，复用-指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll。epoll是最新的也是目前最好的多路复用技术（nginx也是用的epoll机制实现的多路复用）。</p><p>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I&#x2F;O 复用技术可以让单个线程高效的处理多个连接请求(尽量减少网络IO的时间消耗)，且Redis在内存中操作数据的速度非常快(内存内的操作不会成为这里的性能瓶颈)，主要以上两点造就了Redis具有很高的吞吐量。</p><h3 id="2-3、Redis高并发快的总结"><a href="#2-3、Redis高并发快的总结" class="headerlink" title="2.3、Redis高并发快的总结"></a>2.3、Redis高并发快的总结</h3><p>1. Redis是纯内存数据库，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快。</p><p>2. 再说一下IO，Redis使用的是非阻塞IO，IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。</p><p>3. Redis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。</p><p>4. 另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</p><p>5. 还有一点，Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</p><p>🪶上文中的思路不仅仅针对redis、mysql的组合，其他类似的缓存或者场景都可以借鉴。</p>]]></content>
      
      
      <categories>
          
          <category> 开发与测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化在4G网络环境差的地区中项目的响应速度</title>
      <link href="/post/2021/12/14/28080/"/>
      <url>/post/2021/12/14/28080/</url>
      
        <content type="html"><![CDATA[<h2 id="1、背景简述"><a href="#1、背景简述" class="headerlink" title="1、背景简述"></a>1、背景简述</h2><p>最近做了一个网红街的商户收银系统：包含小商铺场景下用户微信扫码点餐H5、小程序、商家PAD点餐、排号、叫号、时间预测等，堂食多人扫桌码点餐、商家PAD点餐等。在前期的现场测试中发现该地区中国移动，中国电信4G、5G网络带宽低，抖动大。偶尔会出现用户端软件响应速度极慢。</p><h2 id="2、大致结构"><a href="#2、大致结构" class="headerlink" title="2、大致结构"></a>2、大致结构</h2><p><img src="https://up.eber.vip/Think-Me/img/main/upload/202304112229307.png" alt="项目结构.png"></p><h2 id="3、当前策略"><a href="#3、当前策略" class="headerlink" title="3、当前策略"></a>3、当前策略</h2><p><strong>目前全站接入HTTP&#x2F;2，目前服务器支持的技术如下：</strong></p><h4 id="1-、多路复用：代替掉HTTP1-x的序列和阻塞机制。同域名下所有通信都在单个连接上完成。单个连接可以承载任意数量的双向数据流。数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。"><a href="#1-、多路复用：代替掉HTTP1-x的序列和阻塞机制。同域名下所有通信都在单个连接上完成。单个连接可以承载任意数量的双向数据流。数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。" class="headerlink" title="(1)、多路复用：代替掉HTTP1.x的序列和阻塞机制。同域名下所有通信都在单个连接上完成。单个连接可以承载任意数量的双向数据流。数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。"></a>(1)、多路复用：代替掉HTTP1.x的序列和阻塞机制。同域名下所有通信都在单个连接上完成。单个连接可以承载任意数量的双向数据流。数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。</h4><p><img src="https://up.eber.vip/Think-Me/img/main/upload/2663160471.png" alt="chromef12.png"></p><h4 id="2-、Server-Push：HTTP-x2F-2-规范中引入的一种新技术，即服务端在没有被客户端明确的询问下，抢先地-“推送”-一些网站资源给客户端（浏览器），该特性可以极大的改善页面访问效果。"><a href="#2-、Server-Push：HTTP-x2F-2-规范中引入的一种新技术，即服务端在没有被客户端明确的询问下，抢先地-“推送”-一些网站资源给客户端（浏览器），该特性可以极大的改善页面访问效果。" class="headerlink" title="(2)、Server Push：HTTP&#x2F;2 规范中引入的一种新技术，即服务端在没有被客户端明确的询问下，抢先地 “推送” 一些网站资源给客户端（浏览器），该特性可以极大的改善页面访问效果。"></a>(2)、Server Push：HTTP&#x2F;2 规范中引入的一种新技术，即服务端在没有被客户端明确的询问下，抢先地 “推送” 一些网站资源给客户端（浏览器），该特性可以极大的改善页面访问效果。</h4><h4 id="3-、头部压缩：HTTP-x2F-2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；首部表在HTTP-x2F-2的连接存续期内始终存在，由客户端和服务器共同渐进地更新-每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。"><a href="#3-、头部压缩：HTTP-x2F-2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；首部表在HTTP-x2F-2的连接存续期内始终存在，由客户端和服务器共同渐进地更新-每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。" class="headerlink" title="(3)、头部压缩：HTTP&#x2F;2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；首部表在HTTP&#x2F;2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。"></a>(3)、头部压缩：HTTP&#x2F;2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；首部表在HTTP&#x2F;2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。</h4><h4 id="3-、WebP：Google推出的一种同时提供了有损压缩与无损压缩的图片文件格式。能最高将图片大小缩减90-左右，非常适合web图片使用。"><a href="#3-、WebP：Google推出的一种同时提供了有损压缩与无损压缩的图片文件格式。能最高将图片大小缩减90-左右，非常适合web图片使用。" class="headerlink" title="(3)、WebP：Google推出的一种同时提供了有损压缩与无损压缩的图片文件格式。能最高将图片大小缩减90%左右，非常适合web图片使用。"></a>(3)、WebP：Google推出的一种同时提供了有损压缩与无损压缩的图片文件格式。能最高将图片大小缩减90%左右，非常适合web图片使用。</h4><h4 id="4-、OCSP-装订缓存：服务器在-TLS-握手时会发送被缓存的OCSP响应，供用户验证，无需用户再向CA发送查询请求。极大地提高了-TLS-握手效率，节省了用户验证时间。"><a href="#4-、OCSP-装订缓存：服务器在-TLS-握手时会发送被缓存的OCSP响应，供用户验证，无需用户再向CA发送查询请求。极大地提高了-TLS-握手效率，节省了用户验证时间。" class="headerlink" title="(4)、OCSP 装订缓存：服务器在 TLS 握手时会发送被缓存的OCSP响应，供用户验证，无需用户再向CA发送查询请求。极大地提高了 TLS 握手效率，节省了用户验证时间。"></a>(4)、OCSP 装订缓存：服务器在 TLS 握手时会发送被缓存的OCSP响应，供用户验证，无需用户再向CA发送查询请求。极大地提高了 TLS 握手效率，节省了用户验证时间。</h4><h4 id="5-、CDN：采用第三方厂商CDN服务来处理静态资源和页面缓存，能在用户访问时通过最近最优的节点去返回缓存资源，大大的优化了资源在网络传输中的效率。"><a href="#5-、CDN：采用第三方厂商CDN服务来处理静态资源和页面缓存，能在用户访问时通过最近最优的节点去返回缓存资源，大大的优化了资源在网络传输中的效率。" class="headerlink" title="(5)、CDN：采用第三方厂商CDN服务来处理静态资源和页面缓存，能在用户访问时通过最近最优的节点去返回缓存资源，大大的优化了资源在网络传输中的效率。"></a>(5)、CDN：采用第三方厂商CDN服务来处理静态资源和页面缓存，能在用户访问时通过最近最优的节点去返回缓存资源，大大的优化了资源在网络传输中的效率。</h4><h2 id="4、优化方案"><a href="#4、优化方案" class="headerlink" title="4、优化方案"></a>4、优化方案</h2><p>理论上如上操作即可极大的增强用户体验，但是仅仅是能提升正常网络状态下的用户体验。而针对高延迟，抖动大的弱网络环境仅仅做到上述策略还不够。</p><p><strong>首先想到的是TCP和UDP两种协议的优缺点：</strong></p><p><strong>TCP：可靠、稳定，但是建连需要经过3次握手，相对繁琐、效率低且占用系统资源高。</strong></p><p><strong>UDP：效率高、快、轻量，占用系统资源较少，但是存在不可靠、无序等缺点。</strong></p><p>基于TCP和UDP的优缺点，<strong>Google</strong>制定了一种<strong>基于UDP</strong>的低时延的互联网传输层协议—–即<strong>QUIC</strong>（Quick UDP Internet Connection）</p><p>在看了多个互联网产品的（微博、网易云信等）QUIC 加速服务架构与实践文档后，决定对现有的测试环境服务做QUIC改造并现场进行测试。</p><p>现有的开源实现：<br>1、quiche：这个是用 Rust 做的库，通过nginx调用。【不是Google的quiche库】<br>2、ATS：Apache Traffic Server<br>3、golang：Caddy；<br>4、python+C，aioquic<br>5、微软msquic</p><p>考虑到通用性和性能，我们最终选择了基于go的Caddy server进行测试。</p><p>因为caddy的v1版本和v2版本的配置是不相通的，所以往上很多文章都是已经过时的，我们看看官网怎么说：</p><p><strong>For example, to configure different options for the servers on port :80 and :443, you would specify two servers blocks:</strong>[<a href="https://caddyserver.com/docs/caddyfile/options#server-options">原文链接</a>]</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">servers :443 &#123;</span><br><span class="line">protocol &#123;</span><br><span class="line">experimental_http3</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">servers :80 &#123;</span><br><span class="line">protocol &#123;</span><br><span class="line">allow_h2c</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述servers :443代码块就是实现HTTP&#x2F;3（HTTP Over QUIC）的配置方式，示例中也提到了以明文方式传输HTTP&#x2F;2（即H2C –”Cleartext HTTP&#x2F;2” or “H2 over TCP”）的开启方式。</p><p>官网对这两个代码块也是有详细说明的：</p><p>allow_h2c：enables H2C (“Cleartext HTTP&#x2F;2” or “H2 over TCP”) support, which will serve HTTP&#x2F;2 over plaintext TCP connections if a client support it. Because this is not implemented by the Go standard library, using H2C is incompatible with most of the other options for this server. Do not enable this only to achieve maximum client compatibility. In practice, very few clients implement H2C, and even fewer require it. This setting applies only to unencrypted HTTP listeners. ⚠️ Experimental feature; subject to change or removal.<strong>（大概意思就是H2C实际上不会有人去用，此功能只是个实验性的功能，未来可能会更改或者删除。）</strong></p><p>experimental_http3：enables experimental draft HTTP&#x2F;3 support. Note that HTTP&#x2F;3 is not a finished spec and client support is extremely limited. This option will go away in the future. This option is not subject to compatibility promises.<strong>（大概意思是HTTP&#x2F;3不是完整的规范，客户端支持也有限。此选项未来会消失。也不受到兼容性承诺的约束。）</strong></p><p>我们在测试中只需要在servers块下创建protocol块，然后指定experimental_http3即可。<br>即：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">servers :443 &#123;</span><br><span class="line">protocol &#123;</span><br><span class="line">experimental_http3</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意⚠️ caddy的配置文件是按行区分的，是不带句尾分号的  ；</p><p>在实现HTTP&#x2F;3之后，我们使用多种设备和运营商卡进行了多次现场测试。原本在现场遇到弱网情况下需要7s左右才能Finish的页面现在仅仅需要2s。极大的提升了加载速度！</p><p>得到测试结论后，我们要做的就是线上生产环境的改造。这时一个新的问题摆在我们面前：<strong>腾讯云CDN不支持HTTP&#x2F;3。</strong></p><p>这里我们进行了讨论得出两种方案：<br>1、自建一个小型的CDN网络供这个服务使用。<br>2、使用支持HTTP&#x2F;3的CDN厂家。</p><p>第一个成本就比较高了，维护起来也比较麻烦。所以我们就选择了第二个方案，把这个服务接入到了支持HTTP&#x2F;3协议的CDN厂家。这里就不做推荐了，大家要善用搜索引擎。</p>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP3 </tag>
            
            <tag> QUIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx的动静态gzip压缩配置及参数详解</title>
      <link href="/post/2021/12/05/49759/"/>
      <url>/post/2021/12/05/49759/</url>
      
        <content type="html"><![CDATA[<h2 id="gzip的两种实现方式。"><a href="#gzip的两种实现方式。" class="headerlink" title="gzip的两种实现方式。"></a>gzip的两种实现方式。</h2><h3 id="1、动态gzip压缩的实现。"><a href="#1、动态gzip压缩的实现。" class="headerlink" title="1、动态gzip压缩的实现。"></a>1、动态gzip压缩的实现。</h3><p>当前端Vue使用普通的编译打包的方式构建出index.html,xxx.js,xxx.css等文件后，可以直接放到nginx的虚拟主机根目录下即可通过绑定的域名去访问。这时如果想开启gzip压缩则按照如下示例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip on; <span class="comment"># 打开gzip</span></span><br><span class="line">gzip_buffers 16 8k; <span class="comment"># 缓冲区数量和大小 （按照内存页大小以8K为单位申请16倍的内存空间）</span></span><br><span class="line">gzip_comp_level 6; <span class="comment"># 压缩级别1-9级别越大越吃性能，压缩比越高，视实际配置设置</span></span><br><span class="line">gzip_http_version 1.1; <span class="comment"># 用于识别http协议的版本，早期的浏览器不支持gzip压缩，用户会看到乱码，所以为了支持前期版本加了此选项。默认在http/1.0的协议下不开启gzip压缩。</span></span><br><span class="line">gzip_min_length 256; <span class="comment"># 最小触发值,以K为单位,当值为0时，所有页面都进行压缩。</span></span><br><span class="line">gzip_proxied any; <span class="comment"># Nginx做为反向代理的时候启用：off – 关闭所有的代理结果数据压缩；expired – 如果header中包含”Expires”头信息，启用压缩；no-cache – 如果header中包含”Cache-Control:no-cache”头信息，启用压缩；no-store – 如果header中包含”Cache-Control:no-store”头信息，启用压缩；private – 如果header中包含”Cache-Control:private”头信息，启用压缩；no_last_modified – 启用压缩，如果header中包含”Last_Modified”头信息，启用压缩；no_etag – 启用压缩，如果header中包含“ETag”头信息，启用压缩；auth – 启用压缩，如果header中包含“Authorization”头信息，启用压缩；any – 无条件压缩所有结果数据</span></span><br><span class="line">gzip_vary on; <span class="comment"># 增加响应头”Vary: Accept-Encoding”</span></span><br><span class="line">gzip_types</span><br><span class="line">  text/xml application/xml application/atom+xml application/rss+xml application/xhtml+xml image/svg+xml</span><br><span class="line">  text/javascript application/javascript application/x-javascript</span><br><span class="line">  text/x-json application/json application/x-web-app-manifest+json</span><br><span class="line">  text/css text/plain text/x-component</span><br><span class="line">  font/opentype application/x-font-ttf application/vnd.ms-fontobject</span><br><span class="line">  image/x-icon; <span class="comment"># 设置需要压缩的MIME类型,如果不在设置类型范围内的请求不进行压缩。推荐直接使用我这里定义的这些类型。</span></span><br><span class="line">gzip_disable <span class="string">&quot;MSIE [1-6]\.(?!.*SV1)&quot;</span>; <span class="comment"># 通过表达式，表明哪些UA头不使用gzip压缩</span></span><br></pre></td></tr></table></figure><p>配置完成之后，直接执行<code>nginx -s reload</code> 即可生效。<br><img src="https://up.eber.vip/Think-Me/img/main/upload/1346039141.webp" alt="00f455cf0cd54bd384211ff658d22fbb.png"><br>浏览器控制台把Content-Encoding显示打开即可查看到有gzip压缩在生效。</p><hr><h3 id="2、静态gzip压缩的实现"><a href="#2、静态gzip压缩的实现" class="headerlink" title="2、静态gzip压缩的实现"></a>2、静态gzip压缩的实现</h3><p>方法1中的动态压缩有一个缺点就是：客户端每次过来请求时服务端都需要进行压缩，而每次都是来对这些静态资源进行压缩，就有点资源浪费的感觉。我们自然而然的就会想到能不能把这些静态资源提前压缩成gz包，这样就不需要服务端去重复做着相同的压缩指令。<br>当然了，这个需要前端人员的配合。</p><p>首先需要在前端安装压缩插件：compression-webpack-plugin然后在vue.config.js中增加如下配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new CompressionPlugin(&#123;</span><br><span class="line">        test: /\.(js|css)(\?.*)?$/i, // 哪些文件要压缩</span><br><span class="line">        filename: &#x27;[path][base].gz[query]&#x27;, // 压缩后的文件名</span><br><span class="line">        algorithm: &#x27;gzip&#x27;, // 使用gzip压缩</span><br><span class="line">        threshold: 10240, //超过10K的文件才会压缩</span><br><span class="line">        minRatio: 0.8, // 压缩率 取值要&lt;1.0</span><br><span class="line">        deleteOriginalAssets: true // 删除未压缩的文件，谨慎设置，如果希望提供非gzip的资源，可不设置或者设置为false</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure><p>打包完之后同样的步骤上传到nginx的虚拟主机根目录，然后nginx需要一个有http_gzip_static_module模块【ps：这里推荐使用春哥的openresty，虽然我们不是巨人，但是我们要学会站在巨人的肩膀上】有了模块之后需要设置gzip_static on;才可以正常解析静态gz资源。<br>注：gzip_static on;可以设置到http、server或者location中。</p><hr><h3 id="3、反向代理到gz静态压缩资源的处理"><a href="#3、反向代理到gz静态压缩资源的处理" class="headerlink" title="3、反向代理到gz静态压缩资源的处理"></a>3、反向代理到gz静态压缩资源的处理</h3><p>有时候我们的前端资源并不是直接在最外层的web服务器中，大多数情况下都是最外层的web服务器反代到内网的某个服务上。例如下面这种简单的反代结构：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">Client((Client))</span><br><span class="line">NGINX[网关NGINX]</span><br><span class="line">backed[应用NGINX/TOMCAT等]</span><br><span class="line">Client--&gt;|访问|NGINX </span><br><span class="line">NGINX--&gt;|反代|backed</span><br></pre></td></tr></table></figure><p>这时如果没有做额外处理的话gzip压缩的资源请求将会404，我们需要做以下处理即可解决该问题。</p><p>分析：因为静态压缩后实际的资源为gz包而非js等原文件，所以直接请求xxx.js将会报404。所以我们首先想到的应该是重写请求为gz。</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> /<span class="variable">$1</span>.gz <span class="literal">break</span>; <span class="comment"># 使用rewrite将请求重写为.gz的请求</span></span><br></pre></td></tr></table></figure><p>再分析：如上操作后，确实是能在【应用NGINX&#x2F;TOMCAT等】定位到gz文件，但是还是无法解析该资源，所以我们要声明一下资源的Content-Encoding，这样内层的web服务器就能正确的解析到该资源。</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">add_header</span> Content-Encoding gzip;</span><br></pre></td></tr></table></figure><p>针对js和css反代静态压缩资源的完整配置如下：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ .*\.(js|css)?$</span> &#123;</span><br><span class="line">  <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> /<span class="variable">$1</span>.gz <span class="literal">break</span>;</span><br><span class="line">  <span class="attribute">add_header</span> Content-Encoding gzip;</span><br><span class="line">  <span class="attribute">proxy_pass</span> http://10.0.10.35:9001;</span><br><span class="line">  <span class="attribute">include</span> proxy.conf; <span class="comment"># 这个是我定义的公共proxy header处理</span></span><br><span class="line">  <span class="attribute">expires</span> <span class="number">7d</span>;</span><br><span class="line">  <span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> gzip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁盘文件系统---inode</title>
      <link href="/post/2021/11/20/57183/"/>
      <url>/post/2021/11/20/57183/</url>
      
        <content type="html"><![CDATA[<h3 id="1、理解inode，首先要了解文件在硬盘上的储存规则。"><a href="#1、理解inode，首先要了解文件在硬盘上的储存规则。" class="headerlink" title="1、理解inode，首先要了解文件在硬盘上的储存规则。"></a>1、理解inode，首先要了解文件在硬盘上的储存规则。</h3><p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。</p><p>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。</p><p>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。</p><h3 id="2、了解inode的内容"><a href="#2、了解inode的内容" class="headerlink" title="2、了解inode的内容"></a>2、了解inode的内容</h3><p>inode包含文件的元信息，具体来说有以下内容：</p><p>* 文件的字节数</p><p>* 文件拥有者的User ID</p><p>* 文件的Group ID</p><p>* 文件的读、写、执行权限</p><p>* 文件的时间戳，共有三个：ctime指inode创建时间，mtime指文件内容上一次修改的时间，atime指文件最后一次访问的时间。</p><p>* 链接数，即有多少文件名指向这个inode</p><p>* 文件数据block的位置</p><p>可以用stat命令，查看某个文件的inode信息：</p><p>stat example.txt</p><p>总之，除了文件名以外的所有文件信息，都存在inode之中。至于为什么没有文件名，下文会有详细解释。</p><h3 id="3、常规文件系统中inode的大小"><a href="#3、常规文件系统中inode的大小" class="headerlink" title="3、常规文件系统中inode的大小"></a>3、常规文件系统中inode的大小</h3><p>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</p><p>每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么就有1048576个inode，inode table的大小就会达到128MB，占整块硬盘的12.8%。</p><p>查看每个硬盘分区的inode总数和已经使用的数量，可以使用df命令。</p><p>df -i</p><p>查看每个inode节点的大小，可以用如下命令：</p><p>sudo dumpe2fs -h &#x2F;dev&#x2F;hda | grep “Inode size”</p><p>由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。</p><h3 id="4、inode号码"><a href="#4、inode号码" class="headerlink" title="4、inode号码"></a>4、inode号码</h3><p>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。</p><p>这里值得重复一遍，Unix&#x2F;Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。</p><p>使用ls -i命令，可以看到文件名对应的inode号码：</p><p>ls -i example.txt</p><h3 id="5、目录文件"><a href="#5、目录文件" class="headerlink" title="5、目录文件"></a>5、目录文件</h3><p>Unix&#x2F;Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。</p><p>目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。</p><p>ls命令只列出目录文件中的所有文件名：</p><p>ls &#x2F;etc</p><p>ls -i命令列出整个目录文件，即文件名和inode号码：</p><p>ls -i &#x2F;etc</p><p>如果要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。ls -l命令列出文件的详细信息。</p><p>ls -l &#x2F;etc</p><h3 id="6、硬链接"><a href="#6、硬链接" class="headerlink" title="6、硬链接"></a>6、硬链接</h3><p>一般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Unix&#x2F;Linux系统允许，多个文件名指向同一个inode号码。这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。</p><p>ln命令可以创建硬链接：</p><p>ln 源文件 目标文件</p><p>运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做”链接数”，记录指向该inode的文件名总数，这时就会增加1。反过来，删除一个文件名，就会使得inode节点中的”链接数”减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。</p><p>这里顺便说一下目录文件的”链接数”。创建目录时，默认会生成两个目录项：”.”和”..”。前者的inode号码就是当前目录的inode号码，等同于当前目录的”硬链接”；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的”硬链接”。所以，任何一个目录的”硬链接”总数，总是等于2加上它的子目录总数（含隐藏目录）,这里的2是父目录对其的“硬链接”和当前目录下的”.硬链接“。</p><h3 id="7、软链接"><a href="#7、软链接" class="headerlink" title="7、软链接"></a>7、软链接</h3><p>除了硬链接以外，还有一种特殊情况。文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。</p><p>这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化。</p><p>ln -s命令可以创建软链接。</p><p>ln -s 源文文件或目录 目标文件或目录</p><h3 id="8、inode的特殊作用"><a href="#8、inode的特殊作用" class="headerlink" title="8、inode的特殊作用"></a>8、inode的特殊作用</h3><p>由于inode号码与文件名分离，这种机制导致了一些Unix&#x2F;Linux系统特有的现象。</p><p>1. 有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。</p><p>2. 移动文件或重命名文件，只是改变文件名，不影响inode号码。</p><p>3. 打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。</p><p>第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。</p><h3 id="9-实际问题"><a href="#9-实际问题" class="headerlink" title="9 实际问题"></a>9 实际问题</h3><p>在一台配置较低的Linux服务器（内存、硬盘比较小）的&#x2F;data分区内创建文件时，系统提示磁盘空间不足，用df -h命令查看了一下磁盘使用情况，发现&#x2F;data分区只使用了66%，还有12G的剩余空间，按理说不会出现这种问题。 后来用df -i查看了一下&#x2F;data分区的索引节点(inode)，发现已经用满(IUsed&#x3D;100%)，导致系统无法创建新目录和文件。 </p><p>查找原因：</p><p>&#x2F;data&#x2F;cache目录中存在数量非常多的小字节缓存文件，占用的Block不多，但是占用了大量的inode。 </p><p>解决方案：</p><p>1.删除&#x2F;data&#x2F;cache目录中的部分文件，释放出&#x2F;data分区的一部分inode。</p><p>2.使用软连接将空闲分区&#x2F;opt中的newcache目录连接到&#x2F;data&#x2F;cache，使用&#x2F;opt分区的inode来缓解&#x2F;data分区inode不足的问题: <code>ln -s /opt/newcache /data/cache</code></p>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> PVE </tag>
            
            <tag> inode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenLiteSpeed的常用重写规则和头部操作</title>
      <link href="/post/2021/11/15/13822/"/>
      <url>/post/2021/11/15/13822/</url>
      
        <content type="html"><![CDATA[<p><img src="https://up.eber.vip/Think-Me/img/main/upload/openlitespeed.png" alt="openlitespeed.png"></p><h2 id="1、http-301-to-https-htaccess规则【-to-www视具体情况增减】"><a href="#1、http-301-to-https-htaccess规则【-to-www视具体情况增减】" class="headerlink" title="1、http 301 to https .htaccess规则【@ to www视具体情况增减】"></a>1、http 301 to https .htaccess规则【@ to www视具体情况增减】</h2><h3 id="1-1、虚拟主机—重写—重写规则"><a href="#1-1、虚拟主机—重写—重写规则" class="headerlink" title="1.1、虚拟主机—重写—重写规则"></a>1.1、虚拟主机—重写—重写规则</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RewriteCond %&#123;HTTPS&#125; off [OR]</span><br><span class="line">RewriteCond %&#123;HTTP_HOST&#125; !^www.</span><br><span class="line">RewriteRule ^(.*)$ https://www.%&#123;SERVER_NAME&#125;/$1 [L,R=301]</span><br></pre></td></tr></table></figure><h3 id="1-2、http-to-https"><a href="#1-2、http-to-https" class="headerlink" title="1.2、http to https"></a>1.2、http to https</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RewriteEngine On</span><br><span class="line">RewriteCond %&#123;SERVER_PORT&#125; 80</span><br><span class="line">RewriteRule ^(.*)$ https://%&#123;SERVER_NAME&#125;/$1 [R,L]</span><br></pre></td></tr></table></figure><h2 id="2、启用HSTS"><a href="#2、启用HSTS" class="headerlink" title="2、启用HSTS"></a>2、启用HSTS</h2><p>虚拟主机—资源集—static—头部操作</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Strict-Transport-Security: max-age=31536000; includeSubDomains; preload</span><br><span class="line">X-Content-Type-Options nosniff</span><br><span class="line">X-XSS-Protection 1;mode=block</span><br><span class="line">X-Frame-Options SAMEORIGIN</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenLiteSpeed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx配置SSL双向认证【客户端认证】</title>
      <link href="/post/2021/11/15/55508/"/>
      <url>/post/2021/11/15/55508/</url>
      
        <content type="html"><![CDATA[<h2 id="SSL双向认证"><a href="#SSL双向认证" class="headerlink" title="SSL双向认证"></a>SSL双向认证</h2><p>绝大多数SSL应用都以单向认证为主，即客户端只要信任服务端，就可以使用服务端的公钥加密后向服务端发起请求，由服务端的私钥解密之后获得请求数据。</p><p>如果这个过程反过来，让服务端信任客户端，服务端使用客户端的公钥加密之后将数据返回给客户端，其实也是可以做到的，原理和实现跟单向认证都差不多。</p><p>服务端信任客户端的操作往往也会伴随着客户端认证服务端的过程，所以让服务端信任客户端的SSL认证方式往往也被称为SSL双向认证，并且要配置SSL双向认证必须先开启服务端SSL，先配置客户端信任服务端。</p><h2 id="Nginx的SSL双向认证配置"><a href="#Nginx的SSL双向认证配置" class="headerlink" title="Nginx的SSL双向认证配置"></a>Nginx的SSL双向认证配置</h2><h2 id="第一步-开启https访问【服务端证书不一定必须是和客户端是同一CA签发的证书，所以可以用CA机构的正规可信证书】"><a href="#第一步-开启https访问【服务端证书不一定必须是和客户端是同一CA签发的证书，所以可以用CA机构的正规可信证书】" class="headerlink" title="第一步 开启https访问【服务端证书不一定必须是和客户端是同一CA签发的证书，所以可以用CA机构的正规可信证书】"></a>第一步 开启https访问【服务端证书不一定必须是和客户端是同一CA签发的证书，所以可以用CA机构的正规可信证书】</h2><p>根据理论知识，我们必须先开启Nginx的SSL配置，即启用https。这个过程较为简单，目前比较好用的就是亚洲诚信这种免费一年的证书方案。申请免费证书的过程略过，直接贴启用https的配置:【let’s encrypt这个免费证书方案不推荐使用，因为苹果设备会强制进行OCSP校验但是let’s encrypt的OCSP服务在国内访问很慢或者是完全不能访问，所以会造成苹果设备无法打开我们的网站或者是响应慢。】</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  listen [::]:80;</span><br><span class="line">  listen 443 ssl http2;</span><br><span class="line">  listen [::]:443 ssl http2;</span><br><span class="line">  server_name example.com;</span><br><span class="line">  ssl_certificate /usr/local/openresty/nginx/conf/ssl/example.com_chain.crt;</span><br><span class="line">  ssl_certificate_key /usr/local/openresty/nginx/conf/ssl/example.com_key.key;</span><br><span class="line">  ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;</span><br><span class="line">  ssl_ciphers TLS13-AES-256-GCM-SHA384:TLS13-CHACHA20-POLY1305-SHA256:TLS13-AES-128-GCM-SHA256:TLS13-AES-128-CCM-8-SHA256:TLS13-AES-128-CCM-SHA256:EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br><span class="line">  ssl_prefer_server_ciphers on;</span><br><span class="line">  ssl_session_timeout 10m;</span><br><span class="line">  ssl_session_cache builtin:1000 shared:SSL:10m;</span><br><span class="line">  ssl_buffer_size 1400;</span><br><span class="line">  add_header Strict-Transport-Security max-age=15768000;</span><br><span class="line">  ssl_stapling on;</span><br><span class="line">  ssl_stapling_verify on;</span><br><span class="line">  access_log /data/wwwlogs/example.com_nginx.log combined;</span><br><span class="line">  if ($ssl_protocol = &quot;&quot;) &#123; return 301 https://$host$request_uri; &#125;</span><br><span class="line"></span><br><span class="line">  location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|flv|mp4|ico)$ &#123;</span><br><span class="line">    proxy_pass http://10.0.5.1:5000;</span><br><span class="line">    include proxy.conf;</span><br><span class="line">    expires 30d;</span><br><span class="line">    access_log off;</span><br><span class="line">  &#125;</span><br><span class="line">  location ~ .*\.(js|css)?$ &#123;</span><br><span class="line">    proxy_pass http://10.0.5.1:5000;</span><br><span class="line">    include proxy.conf;</span><br><span class="line">    expires 7d;</span><br><span class="line">    access_log off;</span><br><span class="line">  &#125;</span><br><span class="line">  location ~ /(\.user\.ini|\.ht|\.git|\.svn|\.project|LICENSE|README\.md) &#123;</span><br><span class="line">    deny all;</span><br><span class="line">  &#125;</span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://10.0.5.1:5000;</span><br><span class="line">    include proxy.conf;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>特别注意<code>if ($ssl_protocol = &quot;&quot;) &#123; return 301 https://$host$request_uri; &#125;</code>，我们的目的是SSL双向认证，不走https无任何意义，所以必须强制跳转https。</p><h2 id="第二步-生成客户端证书并签证-脚本"><a href="#第二步-生成客户端证书并签证-脚本" class="headerlink" title="第二步 生成客户端证书并签证(脚本)"></a>第二步 生成客户端证书并签证(脚本)</h2><p>这个过程详细描述的文章太多了，这里就不啰嗦介绍openssl和签证过程了，本篇内容是快速生成双向认证配置的证书，所以直接贴脚本就行了，命令都是参考互联网上各种openssl双向配置文档，在此基础之上进行了命令上的简化与非交互式的支持。</p><p>整个目录结构如图:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># tree /usr/local/openresty/nginx/conf/ssl/</span><br><span class="line">/usr/local/openresty/nginx/conf/ssl/</span><br><span class="line">├── create_ca_cert.sh</span><br><span class="line">├── create_client_cert.sh</span><br><span class="line">├── revoke_cert.sh</span><br><span class="line"></span><br><span class="line">0 directories, 3 files </span><br></pre></td></tr></table></figure><p>自行创建<code>/etc/nginx/ssl_certs/</code>，放入三个脚本，分别用于生成CA证书以及CA目录(<code>create_ca_cert.sh</code>脚本的作用，只有第一次需要运行)，创建客户端证书，并用CA证书签证(<code>create_client_cert.sh</code>脚本的作用，必须先生成CA证书)，<code>revoke_cert.sh</code>脚本用于吊销证书，需要收回权限的时候可以使用。</p><p>每个脚本内容如下:</p><ul><li><code>create_ca_cert.sh</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash -e</span><br><span class="line"></span><br><span class="line"># 创建CA根证书</span><br><span class="line"># 非交互式方式创建以下内容:</span><br><span class="line"># 国家名(2个字母的代号)</span><br><span class="line">C=CN</span><br><span class="line"># 省</span><br><span class="line">ST=Shannxi</span><br><span class="line"># 市</span><br><span class="line">L=Xian</span><br><span class="line"># 公司名</span><br><span class="line">O=My Company</span><br><span class="line"># 组织或部门名</span><br><span class="line">OU=技术部</span><br><span class="line"># 服务器FQDN或颁发者名</span><br><span class="line">CN=www.example.com</span><br><span class="line"># 邮箱地址</span><br><span class="line">emailAddress=admin@example.com</span><br><span class="line"></span><br><span class="line">mkdir -p ./demoCA/&#123;private,newcerts&#125;</span><br><span class="line">touch ./demoCA/index.txt</span><br><span class="line">[ ! -f ./demoCA/seria ] &amp;&amp; echo 01 &gt; ./demoCA/serial</span><br><span class="line">[ ! -f ./demoCA/crlnumber ] &amp;&amp; echo 01 &gt; ./demoCA/crlnumber</span><br><span class="line">[ ! -f ./demoCA/cacert.pem ] &amp;&amp; openssl req -utf8 -new -x509 -days 36500 -newkey rsa:2048 -nodes -keyout ./demoCA/private/cakey.pem -out ./demoCA/cacert.pem -subj &quot;/C=$&#123;C&#125;/ST=$&#123;ST&#125;/L=$&#123;L&#125;/O=$&#123;O&#125;/OU=$&#123;OU&#125;/CN=$&#123;CN&#125;/emailAddress=$&#123;emailAddress&#125;&quot;</span><br><span class="line">[ ! -f ./demoCA/private/ca.crl ] &amp;&amp; openssl ca -crldays 36500 -gencrl -out &quot;./demoCA/private/ca.crl&quot; </span><br></pre></td></tr></table></figure><ul><li><code>create_client_cert.sh</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash -e</span><br><span class="line"></span><br><span class="line">show_help() &#123;</span><br><span class="line">    echo &quot;$0 [-h|-?|--help] [--ou ou] [--cn cn] [--email email]&quot;</span><br><span class="line">    echo &quot;-h|-?|--help    显示帮助&quot;</span><br><span class="line">    echo &quot;--ou            设置组织或部门名，如: 技术部&quot;</span><br><span class="line">    echo &quot;--cn            设置FQDN或所有者名，如: 冯宇&quot;</span><br><span class="line">    echo &quot;--email         设置FQDN或所有者邮件，如: fengyu@example.com&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while [[ $# -gt 0 ]]</span><br><span class="line">do</span><br><span class="line">    case $1 in</span><br><span class="line">        -h|-\?|--help)</span><br><span class="line">            show_help</span><br><span class="line">            exit 0</span><br><span class="line">            ;;</span><br><span class="line">        --ou)</span><br><span class="line">            OU=&quot;$&#123;2&#125;&quot;</span><br><span class="line">            shift</span><br><span class="line">            ;;        </span><br><span class="line">        --cn)</span><br><span class="line">            CN=&quot;$&#123;2&#125;&quot;            </span><br><span class="line">            shift</span><br><span class="line">            ;;</span><br><span class="line">        --email)</span><br><span class="line">            emailAddress=&quot;$&#123;2&#125;&quot;            </span><br><span class="line">            shift</span><br><span class="line">            ;;</span><br><span class="line">        --)</span><br><span class="line">            shift</span><br><span class="line">            break</span><br><span class="line">        ;;</span><br><span class="line">        *)</span><br><span class="line">            echo -e &quot;Error: $0 invalid option &#x27;$1&#x27;\nTry &#x27;$0 --help&#x27; for more information.\n&quot; &gt;&amp;2</span><br><span class="line">            exit 1</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">shift</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 创建客户端证书</span><br><span class="line"># 非交互式方式创建以下内容:</span><br><span class="line"># 国家名(2个字母的代号)</span><br><span class="line">C=CN</span><br><span class="line"># 省</span><br><span class="line">ST=Shannxi</span><br><span class="line"># 市</span><br><span class="line">L=Xian</span><br><span class="line"># 公司名</span><br><span class="line">O=My Company</span><br><span class="line"># 组织或部门名</span><br><span class="line">OU=$&#123;OU:-测试部门&#125;</span><br><span class="line"># 服务器FQDN或授予者名</span><br><span class="line">CN=$&#123;CN:-demo&#125;</span><br><span class="line"># 邮箱地址</span><br><span class="line">emailAddress=$&#123;emailAddress:-demo@example.com&#125;</span><br><span class="line"></span><br><span class="line">mkdir -p &quot;$&#123;CN&#125;&quot;</span><br><span class="line"></span><br><span class="line">[ ! -f &quot;$&#123;CN&#125;/$&#123;CN&#125;.key&quot; ] &amp;&amp; openssl req -utf8 -nodes -newkey rsa:2048 -keyout &quot;$&#123;CN&#125;/$&#123;CN&#125;.key&quot; -new -days 36500 -out &quot;$&#123;CN&#125;/$&#123;CN&#125;.csr&quot; -subj &quot;/C=$&#123;C&#125;/ST=$&#123;ST&#125;/L=$&#123;L&#125;/O=$&#123;O&#125;/OU=$&#123;OU&#125;/CN=$&#123;CN&#125;/emailAddress=$&#123;emailAddress&#125;&quot;</span><br><span class="line">[ ! -f &quot;$&#123;CN&#125;/$&#123;CN&#125;.crt&quot; ] &amp;&amp; openssl ca -utf8 -batch -days 36500 -in &quot;$&#123;CN&#125;/$&#123;CN&#125;.csr&quot; -out &quot;$&#123;CN&#125;/$&#123;CN&#125;.crt&quot;</span><br><span class="line">[ ! -f &quot;$&#123;CN&#125;/$&#123;CN&#125;.p12&quot; ] &amp;&amp; openssl pkcs12 -export -clcerts -CApath ./demoCA/ -inkey &quot;$&#123;CN&#125;/$&#123;CN&#125;.key&quot; -in &quot;$&#123;CN&#125;/$&#123;CN&#125;.crt&quot; -certfile &quot;./demoCA/cacert.pem&quot; -passout pass: -out &quot;$&#123;CN&#125;/$&#123;CN&#125;.p12&quot; </span><br></pre></td></tr></table></figure><ul><li><code>revoke_cert.sh</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash -e</span><br><span class="line"></span><br><span class="line"># 吊销一个签证过的证书</span><br><span class="line"></span><br><span class="line">openssl ca -revoke &quot;$&#123;1&#125;/$&#123;1&#125;.crt&quot;</span><br><span class="line">openssl ca -gencrl -out &quot;./demoCA/private/ca.crl&quot; </span><br></pre></td></tr></table></figure><p>简单分析一波脚本，首先是创建CA，对于Ubuntu系统来说，<code>/etc/ssl/openssl.cnf</code>配置中默认的CA路径就是<code>./demoCA</code>，为了不改动默认配置，直接按照默认配置的内容创建这些目录和文件即可。还有就是openssl子命令非常多，但是也和git一样，可以合并命令，比如用一条命令同时生成私钥和签证请求<code>openssl req -nodes -newkey rsa:2048 -keyout client.key -new -out client.csr</code>，在<code>req</code>的同时就做了<code>genrsa</code>。由于创建CA脚本只是第一次运行需要，因此把证书配置直接写死在脚本中就完事了。</p><p>接下来是创建客户端证书，为了简化用户的使用，在服务端帮助用户生成证书并签证，把签证过的证书下发给用户就可以了。由于用户可能是不同部门，不同姓名，不同邮件地址，因此将这三个参数外部化，做一下参数解析，加上友好的命令行提示防止遗忘。这个脚本特别注意最后一行，会生成一个<code>PKCS12</code>格式的证书。openssl默认产生的证书格式都是<code>PEM</code>的，会将公钥和私钥分开，但是浏览器导入的时候需要将这些内容合并起来形成<code>证书链</code>，所以需要将签证过的证书和私钥文件合并成一个<code>PKCS12</code>格式的证书，直接将这个<code>.p12</code>格式的证书交给用户就可以了。</p><p>最后是吊销证书了，当希望收回某个用户的访问权限时，直接运行这个脚本跟上目录名就可以了。</p><p>接下来运行创建CA的脚本:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./create_ca_cert.sh</span><br><span class="line">Generating a 2048 bit RSA private key</span><br><span class="line">.......................+++</span><br><span class="line">........................................................................................................+++</span><br><span class="line">writing new private key to &#x27;./demoCA/private/cakey.pem&#x27;</span><br><span class="line">-----</span><br><span class="line">Using configuration from /usr/ssl/openssl.cnf </span><br></pre></td></tr></table></figure><p>此时产生的<code>./demoCA</code>目录结构如下:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">demoCA/</span><br><span class="line">├── cacert.pem</span><br><span class="line">├── crlnumber</span><br><span class="line">├── crlnumber.old</span><br><span class="line">├── index.txt</span><br><span class="line">├── newcerts</span><br><span class="line">├── private</span><br><span class="line">│   ├── ca.crl</span><br><span class="line">│   └── cakey.pem</span><br><span class="line">└── serial</span><br><span class="line"></span><br><span class="line">2 directories, 7 files </span><br></pre></td></tr></table></figure><p>此时就可以配置nginx了，在上面单向ssl的配置中，追加以下配置:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssl_client_certificate ssl_certs/demoCA/cacert.pem;</span><br><span class="line">ssl_crl ssl_certs/demoCA/private/ca.crl;</span><br><span class="line">ssl_verify_client on; </span><br></pre></td></tr></table></figure><p><code>ssl_client_certificate</code>就是客户端证书的CA证书了，代表此CA签发的证书都是可信的，<code>ssl_verify_client on;</code>代表强制启用客户端认证，非法客户端(无证书，证书不可信)都会返回400错。</p><p>特别注意<code>ssl_crl</code>这个配置，代表Nginx会读取一个CRL(Certificate Revoke List)文件，之前说过，可能会有收回用户权限的需求，因此我们必须有吊销证书的功能，产生一个CRL文件让Nginx知道哪些证书被吊销了即可。</p><blockquote><p><strong>注意</strong>: Nginx配置都是静态的，读取配置文件之后都会加载到内存中，即使文件内容变化也不会重新读取。因此当CRL文件发生变更之后，Nginx并不能意识到有新的证书被吊销了，所以必须使用<code>reload</code>指令让Nginx重新读取配置文件: <code>service nginx reload</code>或<code>nginx -s reload</code></p></blockquote><p>此时重启Nginx服务，就可以完成SSL双向认证配置了。</p><p>我们签发一个证书看看:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ./create_client_cert.sh --ou 财务部 --cn 财务经理 --email cy@example.com</span><br><span class="line">Generating a 2048 bit RSA private key</span><br><span class="line">................................+++</span><br><span class="line">.............................................................................+++</span><br><span class="line">writing new private key to &#x27;财务经理/财务经理.key&#x27;</span><br><span class="line">-----</span><br><span class="line">Using configuration from /usr/ssl/openssl.cnf</span><br><span class="line">Check that the request matches the signature</span><br><span class="line">Signature ok</span><br><span class="line">Certificate Details:</span><br><span class="line">        Serial Number: 1 (0x1)</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Jun 14 16:03:46 2018 GMT</span><br><span class="line">            Not After : May 21 16:03:46 2118 GMT</span><br><span class="line">        Subject:</span><br><span class="line">            countryName               = CN</span><br><span class="line">            stateOrProvinceName       = Shannxi</span><br><span class="line">            organizationName          = My Company</span><br><span class="line">            organizationalUnitName    = \U8D22\U52A1\U90E8</span><br><span class="line">            commonName                = \U8D22\U52A1\U7ECF\U7406</span><br><span class="line">            emailAddress              = cy@example.com</span><br><span class="line">        X509v3 extensions:</span><br><span class="line">            X509v3 Basic Constraints:</span><br><span class="line">                CA:FALSE</span><br><span class="line">            Netscape Comment:</span><br><span class="line">                OpenSSL Generated Certificate</span><br><span class="line">            X509v3 Subject Key Identifier:</span><br><span class="line">                B5:91:0B:1F:FC:25:3B:2A:F9:EF:39:39:51:E3:1F:64:78:8A:C3:75</span><br><span class="line">            X509v3 Authority Key Identifier:</span><br><span class="line">                keyid:86:55:76:15:A3:F5:58:CB:8F:39:A3:56:8E:FF:18:97:AE:27:60:0F</span><br><span class="line"></span><br><span class="line">Certificate is to be certified until May 21 16:03:46 2118 GMT (36500 days)</span><br><span class="line"></span><br><span class="line">Write out database with 1 new entries</span><br><span class="line">Data Base Updated</span><br><span class="line"></span><br><span class="line">tree 财务经理/</span><br><span class="line">财务经理/</span><br><span class="line">├── 财务经理.crt</span><br><span class="line">├── 财务经理.csr</span><br><span class="line">├── 财务经理.key</span><br><span class="line">└── 财务经理.p12</span><br><span class="line"></span><br><span class="line">0 directories, 4 files </span><br></pre></td></tr></table></figure><p>这个脚本生成了私钥文件<code>key</code>，签证请求文件<code>csr</code>，经过CA签证后的证书文件<code>crt</code>(里面没有私钥)，以及将crt文件和key进行bundle之后的<code>PKCS12</code>格式的证书文件<code>p12</code>，将<code>p12</code>文件下载到本地，双击一路Next导入证书即可。</p><blockquote><p><strong>注</strong>: 由于CA的证书文件不会发生变化，因此签证新的客户端证书不需要restart或reload nginx</p></blockquote><p>这次打开我们的网站<code>https://www.example.com</code>，浏览器就会提示我们选择一个已有的客户端证书进行认证了，没问题就可以看到网站内容了</p><blockquote><p><strong>注</strong>: 每次导入新的证书之后，必须重启浏览器才能提示使用新的证书文件</p></blockquote><p>按照这种方式，有多少人需要授权，就可以用这个脚本签发多少个这样的证书，用户将<code>p12</code>证书导入本地就可以正常访问网站了。</p><p>当我们需要收回某人的权限的时候(比如离职了)，我们需要吊销他的证书:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ./revoke_cert.sh 财务经理</span><br><span class="line">Using configuration from /usr/ssl/openssl.cnf</span><br><span class="line">Revoking Certificate 01.</span><br><span class="line">Data Base Updated</span><br><span class="line">Using configuration from /usr/ssl/openssl.cnf</span><br><span class="line"></span><br><span class="line">service nginx reload </span><br></pre></td></tr></table></figure><p>这个脚本会自动吊销他的签证文件<code>crt</code>，并且自动更新<code>CRL</code>文件。特别注意需要reload或restart nginx才能让nginx重新加载CRL。这样被吊销的证书将无法访问网站了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们通过Nginx配置SSL双向认证实现对客户端的加密认证，我们使用了简易的脚本帮助我们快速生成各种证书与签证，免除记忆繁琐openssl命令行，简化使用。</p><p>当然这只是一个最小可用集，当规模比较大的时候可能需要做很多改进，比如加入CA的web ui，直接可以操作签证和吊销证书，并且可以自动重启nginx。</p><p>再比如CRL这种静态配置文件不适合你的场景，希望的动态更新吊销证书列表，那么可以考虑OCSP方案，这个Nginx也是支持的，通过ssl_stapling_responder配置指定一个OCSP地址，这样将不需要每次吊销证书的时候都去重启nginx了，openssl也提供了ocsp服务端的功能，这里就不赘述了，可以自行查找相关资料。</p>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> SSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>acme.sh入门教程</title>
      <link href="/post/2021/10/02/45569/"/>
      <url>/post/2021/10/02/45569/</url>
      
        <content type="html"><![CDATA[<h2 id="acme-sh域名鉴权方式"><a href="#acme-sh域名鉴权方式" class="headerlink" title="acme.sh域名鉴权方式"></a>acme.sh域名鉴权方式</h2><p>由项目的<a href="https://github.com/acmesh-official/acme.sh/wiki/%E8%AF%B4%E6%98%8E#2-%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6">wiki</a>可知：acme.sh内置两种鉴权方式：http 和 dns 验证</p><ul><li>http验证(webroot模式)：有些地方会称为“文件验证”，验证方式是在你的网站根目录下放置一个文件, 来验证你的域名所有权。</li><li>dns验证(dnsapi模式)：验证方式是去你域名解析接入商那里添加一条TXT的记录指向指定的值。</li></ul><h2 id="两种验证的使用方式"><a href="#两种验证的使用方式" class="headerlink" title="两种验证的使用方式"></a>两种验证的使用方式</h2><ul><li><p>http验证一般比较便利，不需要你去acme里配置任何东西，所以一般都是使用这个去进行证书申请鉴权的。</p><p>⚠️ 大陆的网络环境下往往会报验证错误而无法成功申请证书。因为acme会使用cloudflare或google的dns服务器去验证解析是否生效，而google和cloudflare的dns服务在大陆往往不能访问会造成申请失败。但是这个功能在acme的执行过程中不是必要的，所以这时需要我们手动增加一个配置项来跳过public dns check即可。(官方文档中说的是In dns mode会有public dns check，但是我实际使用中http验证过程中也会有public dns check)</p><p>🌰 具体做法为：在<code>.acme.sh/account.conf</code>配置文件末尾增加<code>Le_DNSSleep=&#39;30&#39;</code>官方的说法为 <a href="https://github.com/acmesh-official/acme.sh/wiki/dnscheck"><code>Then acme.sh will wait for 300 seconds instead of checking through the public dns.</code></a> 在我实际测试中没必要一定设置为300。</p><p><code>推荐使用修改配置文件的方式使全局生效</code></p></li><li><p>dns验证稍微麻烦一点，它需要你去配置域名解析服务商的api操作的密钥。目前支持的厂商有<code>cloudflare, dnspod, cloudxns, godaddy 以及 ovh 等数十种解析商</code>具体支持的厂商和用法请查看 <a href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi">wiki</a> 。（申请泛域名证书时必须使用该方式）</p><p>🌰 他的原理其实就是拿到你解析服务商的操作密钥去调用API自动添加TXT解析记录来验证域名的所属权。</p><p><code>我的建议是：除非你需要使用泛域名证书，否则没必要使用dns方式，配置复杂是次要的，主要还是怕API密钥在不经意间被泄漏而造成不必要的麻烦。（这里不是指acme泄露密钥，主要是说你自己不经意间的泄漏）</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acme.sh </tag>
            
            <tag> SSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot单包小项目管理方案</title>
      <link href="/post/2020/07/04/30705/"/>
      <url>/post/2020/07/04/30705/</url>
      
        <content type="html"><![CDATA[<h3 id="1、文章背景"><a href="#1、文章背景" class="headerlink" title="1、文章背景"></a>1、文章背景</h3><p>17年左右刚参加工作时的时候接触的第一个项目是采用SSM开发的，那个时候公司项目一般的部署方式为打war包放到tomcat上，使用tomcat bin下的各种脚本去管理tomcat服务。后来主流开发渐渐的往的springboot靠拢，从之前的打war包上传tomcat中到打jar包直接运行。这中间我一直感觉很不方便，一直在找一种比较方便的单包小项目管理方案。</p><h3 id="2、jar包管理1-0"><a href="#2、jar包管理1-0" class="headerlink" title="2、jar包管理1.0"></a>2、jar包管理1.0</h3><p>刚接触springboot时，网上的各种博文都是教你使用nohup去管理。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> java -jar xxx.jar -jvm parameter &amp;</span><br></pre></td></tr></table></figure><p>nohup：英文全称no hang up（不挂起），用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。 nohup 命令，在默认情况下（非重定向时），会输出一个名叫nohup.out 的文件到当前目录下，如果当前目录的nohup.out 文件不可写，输出重定向到$HOME&#x2F;nohup.out 文件中。</p><p>这样有一个问题就是：你需要记住每个jar包的放置位置，每次操作都要先进到这个目录。并且需要额外的保护措施来避免服务死掉之后无法自行恢复。</p><h3 id="3、jar包管理2-0"><a href="#3、jar包管理2-0" class="headerlink" title="3、jar包管理2.0"></a>3、jar包管理2.0</h3><p>spring官网有一个文档叫做 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/deployment.html#deployment.installing">Deploying Spring Boot Applications</a> 这里面的2.2.2. Installation as a systemd Service中介绍了如何将jar作为系统服务去运行，他提供的例子比较简单。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=myapp</span><br><span class="line">After=syslog.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=myapp</span><br><span class="line">ExecStart=/var/myapp/myapp.jar</span><br><span class="line">SuccessExitStatus=143</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>我们可以参考这个 <a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html">文档</a> 根据需要去填充你的.service文件。<br>service文件配置完成之后需要执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload <span class="comment">#刷新服务</span></span><br><span class="line"></span><br><span class="line">systemctl start/stop/restart xxx.service <span class="comment">#启动停止重启服务</span></span><br></pre></td></tr></table></figure><p>这里还有一个比较好用的功能：比如我们的jar放在&#x2F;usr&#x2F;local&#x2F;app&#x2F;xxx.jar<br>我们只要在此jar包同目录下创建xxx.conf即&#x2F;usr&#x2F;local&#x2F;app&#x2F;xxx.conf，这个文件就可以作为环境变量配置文件，可以export你想要的环境变量，配合项目yml中${ENV_KEY}使用。例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> SERVER_ACTIVE=prod</span><br><span class="line"><span class="built_in">export</span> SERVER_PORT=8080</span><br><span class="line"><span class="built_in">export</span> DB_HOST=172.17.20.7</span><br><span class="line"><span class="built_in">export</span> DB_PORT=65432</span><br><span class="line"><span class="built_in">export</span> JAVA_OPTS=<span class="string">&quot;-Xmx5440M -Xms5440M -XX:MaxMetaspaceSize=512M -XX:MetaspaceSize=512M -XX:+UseG1GC -XX:MaxGCPauseMillis=100&quot;</span></span><br></pre></td></tr></table></figure><p>⚠️⚠️⚠️ pom.xml文件中spring-boot-maven-plugin的<configuration>配置块中需要配置executable可执行为true。整体修改后的效果类似这样：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.5.8&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;executable&gt;<span class="literal">true</span>&lt;/executable&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><h3 id="4、优化jar包大小"><a href="#4、优化jar包大小" class="headerlink" title="4、优化jar包大小"></a>4、优化jar包大小</h3><p>在构建单jar包时，因为所有的依赖和代码都构建到一个jar包中导致容量过大，并且在项目迭代时依赖一般没有很大的改动，所以就需要配置maven将依赖和代码分开构建，这样每次构建出的代码包只有不到1M的大小，能很方便的上传。依赖有增删的可以直接在依赖文件夹中操作。</p><h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><h3 id="pm2或同类型进程管理工具-supervisor等"><a href="#pm2或同类型进程管理工具-supervisor等" class="headerlink" title="pm2或同类型进程管理工具(supervisor等)"></a>pm2或同类型进程管理工具(supervisor等)</h3><p>pm2是一个nodejs的进程管理工具，可以很方便的管理nodejs进程，但是也可以管理java进程。pm2的安装和使用可以参考 <a href="https://pm2.keymetrics.io/">pm2官网</a> 。pm2的优点是可以很方便的管理多个进程，下面简单讲一下安装和使用。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装nvm 用来安装和管理nodejs</span></span><br><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.2/install.sh | bash</span><br><span class="line"><span class="comment"># 安装nodejs</span></span><br><span class="line">nvm install node</span><br><span class="line"><span class="comment"># 全局安装pm2</span></span><br><span class="line">npm install pm2 -g</span><br><span class="line"><span class="comment"># 根据回显信息执行命令后可以配置pm2自启动</span></span><br><span class="line">pm2 startup</span><br></pre></td></tr></table></figure><p>安装完成后，如果是守护不太复杂的可执行程序可以直接 <code>pm2 start ./program --name name -- --arg arg</code>，–后面的参数会传递进去。</p><p>如果是java这种启动比较复杂的程序，可以先写个js文件，然后通过 <code>pm2 start app.js</code> 来启动。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写app.js</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;app&quot;</span>,</span><br><span class="line">    <span class="string">&quot;script&quot;</span>: <span class="string">&quot;/usr/bin/java&quot;</span>, <span class="comment"># java可执行文件路径</span></span><br><span class="line">    <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;-jar&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/usr/local/app.jar&quot;</span>, <span class="comment"># jar包路径</span></span><br><span class="line">        <span class="string">&quot;--spring.profiles.active=prod&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;exec_interpreter&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;exec_mode&quot;</span>: <span class="string">&quot;fork&quot;</span>,</span><br><span class="line">    <span class="string">&quot;error_file&quot;</span> : <span class="string">&quot;/var/logs/app-error.log&quot;</span>,</span><br><span class="line">    <span class="string">&quot;out_file&quot;</span>   : <span class="string">&quot;/var/logs/app.log&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 list <span class="comment"># 查看当前所有进程的状态</span></span><br><span class="line">pm2 start app <span class="comment"># 启动app进程</span></span><br><span class="line">pm2 stop app <span class="comment"># 停止app进程</span></span><br><span class="line">pm2 restart app <span class="comment"># 重启app进程</span></span><br><span class="line">pm2 delete app <span class="comment"># 删除app进程</span></span><br><span class="line">pm2 monit <span class="comment"># 查看当前所有进程的资源占用情况</span></span><br><span class="line">pm2 <span class="built_in">log</span> <span class="comment"># 查看当前所有进程的日志</span></span><br></pre></td></tr></table></figure><p>pm2还有很多功能，比如：负载均衡、日志分割、可视化监控等，可以根据自己的需求去官网学习使用。</p>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> pm2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷歌黑语法</title>
      <link href="/post/2020/04/22/26950/"/>
      <url>/post/2020/04/22/26950/</url>
      
        <content type="html"><![CDATA[<h2 id="谷歌黑语法"><a href="#谷歌黑语法" class="headerlink" title="谷歌黑语法"></a>谷歌黑语法</h2><p>简介：原本是google的搜索引擎中使用快速查询的语法，后来发展成谷歌黑客 (Google hacking)，也叫Google dorking，是一种利用谷歌搜索和其他谷歌应用程序来发现网站配置和计算机代码中的安全漏洞的计算机黑客技术。</p><h4 id="基本脑图"><a href="#基本脑图" class="headerlink" title="基本脑图"></a>基本脑图</h4><p><img src="https://up.eber.vip/Think-Me/img/main/upload/593188852.jpg" alt="Jietu20200422-192337@2x.jpg"></p><p>基本使用方式：<br>site:csdn.net filetype:doc  在指定网站搜索指定后缀的文件<br>site:xx.com inurl:login  找登录入口<br>site:xx.com inurl:admin  尝试找一下管理员登录的入口</p><p>还有下面一些妙用自己细细品哈<br>site:wcipeg.com intitle:”index of” etc<br>intitle:”Index of” .sh_history<br>intitle:”Index of” .bash_history<br>intitle:”index of” passwd<br>intitle:”index of” people.lst<br>intitle:”index of” pwd.db<br>intitle:”index of” etc&#x2F;shadow<br>intitle:”index of” spwd<br>intitle:”index of” master.passwd<br>intitle:”index of” htpasswd<br>“# -FrontPage-” inurl:service.pwd<br>等等一些相关的语法，可以去google.com上搜到，这里就不一一列举了。<br>这里再推荐一个网站 <a href="https://www.exploit-db.com/google-hacking-database">Google Hacking Database</a> （可能需要科学上网）</p><h4 id="如何预防"><a href="#如何预防" class="headerlink" title="如何预防"></a>如何预防</h4><p>对于普通站长而言更想了解的是如何预防</p><ul><li><p><strong>——<em>robots.txt</em>——</strong><br>站点根目录下建立一个robots.txt写规则以避免搜索引擎的爬虫获取某些敏感的信息。(这样可以避免正规的爬虫去抓取，但是某些爬虫并不按照规矩做事。)</p></li><li><p><strong>——<em>通过nginx配置防止爬虫</em>——</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ($http_user_agent ~* &quot;qihoobot|Baiduspider|Googlebot|Googlebot-Mobile|Googlebot-Image|Mediapartners-Google|Adsbot-Google|Feedfetcher-Google|Yahoo! Slurp|Yahoo! Slurp China|YoudaoBot|Sosospider|Sogou spider|Sogou web spider|MSNBot|ia_archiver|Tomato Bot&quot;)</span><br><span class="line">&#123;</span><br><span class="line">return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该配置要加在&#x2F;全局通过规则的上面（nginx配置规则：范围小的规则放在上面、范围大的放在下面）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 谷歌黑语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker和docker-compose的安装</title>
      <link href="/post/2019/07/03/32355/"/>
      <url>/post/2019/07/03/32355/</url>
      
        <content type="html"><![CDATA[<h3 id="先介绍一下docker是啥："><a href="#先介绍一下docker是啥：" class="headerlink" title="先介绍一下docker是啥："></a>先介绍一下docker是啥：</h3><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的Linux机器或Windows 机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。  </p><h3 id="再说一下docker-compose是啥："><a href="#再说一下docker-compose是啥：" class="headerlink" title="再说一下docker compose是啥："></a>再说一下docker compose是啥：</h3><p>docker compose是docker三剑客之一，用于定义和运行多个容器 Docker 应用程序的工具。通过docker compose，你可以使用YML文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从YML文件配置中创建并启动所有服务。Compose对应的命令为docker-compose。<br>简单一点说就是把一堆docker组合编排到一起以实现快速管理。</p><h4 id="本文的目的是为了方便我配置swarm，所以用的版本都是比较新的。如果您只是单纯的使用docker或者docker-compose则无需特别新的版本"><a href="#本文的目的是为了方便我配置swarm，所以用的版本都是比较新的。如果您只是单纯的使用docker或者docker-compose则无需特别新的版本" class="headerlink" title="本文的目的是为了方便我配置swarm，所以用的版本都是比较新的。如果您只是单纯的使用docker或者docker compose则无需特别新的版本"></a><font color=red>本文的目的是为了方便我配置swarm，所以用的版本都是比较新的。如果您只是单纯的使用docker或者docker compose则无需特别新的版本</font></h4><h3 id="好了，回归正题"><a href="#好了，回归正题" class="headerlink" title="好了，回归正题"></a>好了，回归正题</h3><h4 id="1、如何安装docker"><a href="#1、如何安装docker" class="headerlink" title="1、如何安装docker"></a>1、如何安装docker</h4><p>先查看内核版本以确定兼容哪些docker版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ecs ~]<span class="comment"># uname -r</span></span><br><span class="line">3.10.0-1062.9.1.el7.x86_64</span><br></pre></td></tr></table></figure><p>如果这个地方显示内核版本为3.10.0则最大支持到docker-18.03.1.ce版本<br>我们想安装比较新的版本【因为旧版本不支持有些新特性】，所以我们首先要升级服务器的内核版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ecs ~]<span class="comment"># rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span></span><br><span class="line">[root@ecs ~]<span class="comment"># rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm</span></span><br><span class="line">[root@ecs ~]<span class="comment"># yum --enablerepo=elrepo-kernel install  kernel-ml-devel kernel-ml -y</span></span><br><span class="line">[root@ecs ~]<span class="comment"># grub2-set-default 0</span></span><br><span class="line">[root@ecs ~]<span class="comment"># reboot</span></span><br></pre></td></tr></table></figure><p>服务器正常重启之后可以看你心情选择是否执行以下命令去删除旧内核【可选项】</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ecs ~]<span class="comment"># yum remove kernel</span></span><br></pre></td></tr></table></figure><p>####ok,现在可以开始安装docker了<br>先看看是否有旧版本的docker，如果有可以用以下命令去卸载</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ecs ~]<span class="comment"># yum remove docker docker-common docker-selinux docker-engine docer-io</span></span><br></pre></td></tr></table></figure><ul><li>首先我们要更新一下yum包<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ecs ~]<span class="comment"># yum update -y</span></span><br></pre></td></tr></table></figure></li><li>其次要安装要依赖的软件包【yum-util 提供 yum-config-manager 功能， 另外两个是 devicemapper 驱动依赖】<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ecs ~]<span class="comment"># yum install -y yum-utils device-mapper-persistent-data lvm2</span></span><br></pre></td></tr></table></figure></li><li>然后设置yum源<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ecs ~]<span class="comment"># yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure></li><li>再查看仓库中所有docker版本，选择你想要的版本去安装<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ecs ~]<span class="comment"># yum list docker-ce --showduplicates | sort -r</span></span><br></pre></td></tr></table></figure></li><li>这里我需要docker-18.06.3.ce版本，你们按照你们的需求去选择版本<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ecs ~]<span class="comment"># yum install -y docker-ce-18.06.3.ce</span></span><br></pre></td></tr></table></figure></li><li>最后启动并加入开机自启<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ecs ~]<span class="comment"># systemctl start docker</span></span><br><span class="line">[root@ecs ~]<span class="comment"># systemctl enable docker</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2、如何安装docker-compose"><a href="#2、如何安装docker-compose" class="headerlink" title="2、如何安装docker compose"></a>2、如何安装docker compose</h4><p>通过访问 <a href="https://github.com/docker/compose/releases">https://github.com/docker/compose/releases</a> 可以查看现有的所有版本，去选择合适的版本。<br>这里由于我需要最新的3.7的特性，所以刚才docker安装的版本是18.06.3，docker-compose我也选择最新的【1.24.1版本】去安装以支持新特性。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ecs ~]<span class="comment"># curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span></span><br><span class="line">[root@ecs ~]<span class="comment"># chmod +x /usr/local/bin/docker-compose</span></span><br><span class="line">[root@ecs ~]<span class="comment"># docker-compose --version</span></span><br><span class="line">docker-compose version 1.24.1, build 4667896b</span><br></pre></td></tr></table></figure><p>最终显示docker-compose的版本即为安装成功。</p><h5 id="注意：-docker和docker-compose配置文件里面版本要按照下面表格要求对应"><a href="#注意：-docker和docker-compose配置文件里面版本要按照下面表格要求对应" class="headerlink" title="注意：  docker和docker compose配置文件里面版本要按照下面表格要求对应"></a><font color=red>注意：</font>  docker和docker compose配置文件里面版本要按照下面表格要求对应</h5><p>即docker-compose.yml配置文件的第一行的这个版本号</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.7&quot;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">compose文件版本</th><th align="center">docker版本</th></tr></thead><tbody><tr><td align="left">1</td><td align="center">1.9.0+</td></tr><tr><td align="left">2.0</td><td align="center">1.10.0+</td></tr><tr><td align="left">2.1</td><td align="center">1.12.0+</td></tr><tr><td align="left">2.2, 3.0, 3.1, 3.2</td><td align="center">1.13.0+</td></tr><tr><td align="left">2.3, 3.3, 3.4, 3.5</td><td align="center">17.06.0+</td></tr><tr><td align="left">2.4</td><td align="center">17.12.0+</td></tr><tr><td align="left">3.6</td><td align="center">18.02.0+</td></tr><tr><td align="left">3.7</td><td align="center">18.06.0+</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot与Docker部署</title>
      <link href="/post/2019/05/02/1879/"/>
      <url>/post/2019/05/02/1879/</url>
      
        <content type="html"><![CDATA[<h3 id="第一种：结合编辑器使用"><a href="#第一种：结合编辑器使用" class="headerlink" title="第一种：结合编辑器使用"></a>第一种：结合编辑器使用</h3><p><em><strong>1、开启Docker远程访问</strong></em><br>首先需要开启docker远程访问功能，以便可以进行远程操作。<br>以centos7为例：打开&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service文件，修改ExecStart这行。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd  -H tcp://0.0.0.0:2375  -H unix:///var/run/docker.sock</span><br></pre></td></tr></table></figure><p>重启后生效</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload    </span><br><span class="line">systemctl restart docker.service </span><br></pre></td></tr></table></figure><p>测试是否生效</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://127.0.0.1:2375/info</span><br></pre></td></tr></table></figure><p><em><strong>2、新建maven工程</strong></em><br>主要部分</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.4.14&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;imageName&gt;$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;&lt;/imageName&gt;</span><br><span class="line">        &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt;</span><br><span class="line">        &lt;dockerHost&gt;http://10.100.0.111:2375&lt;/dockerHost&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;targetPath&gt;/&lt;/targetPath&gt;</span><br><span class="line">                &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt;</span><br><span class="line">                &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt;</span><br><span class="line">            &lt;/resource&gt;</span><br><span class="line">        &lt;/resources&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><p>imageName：指定了镜像的名字<br>dockerDirectory：指定Dockerfile的位置<br>dockerHost：指定Docker远程API地址<br>resources：指那些需要和Dockerfile放在一起，在构建镜像时使用的文件，一般应用jar包需要纳入</p><p><em><strong>3、创建Dockerfile</strong></em><br>在src&#x2F;main&#x2F;docker目录下创建一个名为Dockerfile的文件，配置如下：  【一定要注意路径】</p><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java</span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /tmp</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> docker-springboot-0.0.1-SNAPSHOT.jar app.jar</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> bash -c <span class="string">&#x27;touch /app.jar&#x27;</span></span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_OPTS=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;java <span class="variable">$JAVA_OPTS</span> -Djava.security.egd=file:/dev/./urandom -jar /app.jar&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>FROM java：指Docker Hub上官方提供的java镜像，有了这个基础镜像后，Dockerfile可以通过FROM指令直接获取它的状态——也就是在容器中java是已经安装的，接下来通过自定义的命令来运行Spring Boot应用。</p><p>VOLUME &#x2F;tmp：创建&#x2F;tmp目录并持久化到Docker数据文件夹，因为Spring Boot使用的内嵌Tomcat容器默认使用&#x2F;tmp作为工作目录。</p><p>ADD docker-springboot-0.0.1-SNAPSHOT.jar app.jar：将应用jar包复制到&#x2F;app.jar</p><p>ENTRYPOINT：表示容器运行后默认执行的命令</p><p><em><strong>4、运行以下命令创建Docker镜像：</strong></em><br>package docker:build</p><p><em><strong>5、Docker启动镜像</strong></em><br>CMD中执行docker images查看镜像是否上传成功<br>使用docker run -p 8888:8080 springboot&#x2F;docker-springboot启动镜像<br>通过浏览器能访问即为成功</p><p>###第二种：单独使用<br>有些时候我们只是临时构建一下没必要那么麻烦<br>直接在含有Dockerfile的项目main目录下直接运行</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mvn clean package docker:build</span><br></pre></td></tr></table></figure><p>即可构建完成并自动上传到本地仓库。</p>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抓取占用CPU高的JAVA线程，进而找出有问题的代码段</title>
      <link href="/post/2018/08/01/29233/"/>
      <url>/post/2018/08/01/29233/</url>
      
        <content type="html"><![CDATA[<p>写在前面：当你的java项目总是出现CPU占用很高的情况（服务器性能极弱除外），很可能因为某段代码出现死锁之类的BUG而导致CPU占用高甚至敲命令都卡顿！在日志无法具体指向的时候，你根本无法确定哪个地方出现了BUG，从而你也没法去解决。下面，就介绍一个抓取高占用CPU的线程的简单方法：</p><pre><code>1.运行top命令取得JAVA线程号(PID)，假如是2068；2.运行jstack + pid 命令导出JAVA线程信息到result文件，命令行为3.jstack 2068&gt;result4.运行top -p 2068 -H 查看CPU占用排名情况，并记录PID；5.运行 ./jtgrep +PID 找到线程头文字(PID为第3步获取) ；6.使用vi/vim打开result，查询头文字就能找到相应线程。</code></pre><p>下面为jtgrep代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#bin/bash   </span></span><br><span class="line">nid =`python -c <span class="string">&quot;print hex(<span class="variable">$1</span>)&quot;</span>` grep -i <span class="variable">$nid</span> <span class="variable">$2</span></span><br></pre></td></tr></table></figure><p>写在后面：此方法无须安装任何软件，能够快速找出占用CPU的JAVA线程，是发现同类问题的首选办法，但很多时候你可能找到的是VM threads线程或者GC线程。。。无法真正找到毒瘤，那就只能另寻他法了。</p>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小白玩转Linux的必备技能——进阶篇</title>
      <link href="/post/2018/07/29/60762/"/>
      <url>/post/2018/07/29/60762/</url>
      
        <content type="html"><![CDATA[<h3 id="玩转Linux的必备技能–进阶篇"><a href="#玩转Linux的必备技能–进阶篇" class="headerlink" title="玩转Linux的必备技能–进阶篇"></a>玩转Linux的必备技能–进阶篇</h3><h4 id="如下："><a href="#如下：" class="headerlink" title="如下："></a>如下：</h4><p><em><strong>1、启用root用户</strong></em></p><p>某些公有云服务商不会直接提供给你root账户，而是给你密钥或者是其他用户，这种情况下就需要我们手动开启root账户并设置密码登录。</p><ul><li>先用云服务商提供给你的密钥文件或者是其他用户登录上去</li><li>然后执行sudo su获得root权限</li><li>执行vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config找到<strong>PermitRootLogin</strong>和<strong>PasswordAuthentication</strong>如果这两项前面有注释则去掉注释并将后面改为<strong>yes</strong></li><li>文件保存退出后执行<strong>passwd root</strong>按照提示进行root账户的密码设置(输入的密码不会显示)</li><li>最后执行<strong>systemctl restart sshd</strong>重启ssh服务，然后就可以用root用户登录了</li></ul><p><em><strong>2、了解Linux的目录结构</strong></em></p><ul><li>&#x2F; ：根目录，每一个文件和目录从根目录开始，只有root用户具有该目录下的写权限。</li><li>&#x2F;bin ： 用户二进制文件包含二进制可执行文件。在单用户模式下，你需要使用的常见Linux命令都位于此目录下。系统的所有用户使用的命令都设在这里。</li><li>&#x2F;boot ：主要放置开关机会使用的文件，包括Linux 内核文件以及开关机菜单与开机所需要的配置文件。</li><li>&#x2F;dev ：在Linux 系统中所有的设备与接口设备都是以文件的形式存放在这个目录中。只要访问这个目录下的某个文件就相当于访问某个设备。</li><li>&#x2F;etc ：所有系统管理所需要的配置文件和子目录。比如设置运行级别。</li><li>&#x2F;home ：存放普通用户的主目录，在Linux 系统中每个用户都有一个独立的目录，一般该目录名以账号用户名命名。</li><li>&#x2F;lib ：系统开机所需要的最基本的动态链接共享库，功能类似于Windows 中的DLL 文件。几乎所有的应用程序都需要用到这些共享库。</li><li>&#x2F;lost + found ：这个目录一般是空的，当用户非法关机后会保存一些文件。</li><li>&#x2F;misc ：挂载外部设备</li><li>&#x2F;media ：Linux 系统会自动识别一些设备，例如U 盘、光驱等，当识别后Linux 会把识别的设备挂在这个目录下。</li><li>&#x2F;mnt ：为了让用户临时挂载别的文件系统，我们可以将光驱挂在在该目录中。</li><li>&#x2F;opt ：给主机安装额外软件所摆放的目录。默认情况下是空的。比如我们可以将数据库安装在这个目录下。</li><li>&#x2F;proc ：这个目录上是一个虚拟的目录，它是系统内存的映射，我们通常可以访问这个目录来获取系统信息。</li><li>&#x2F;root ：该目录为系统管理员的主目录。</li><li>&#x2F;sbin ：Super Bin的意思， 系统二进制文件，就像&#x2F;bin，&#x2F;sbin同样也包含二进制可执行文件。但是，在这个目录下的linux命令通常由系统管理员使用，对系统进行维护。</li><li>&#x2F;selinux ：这个目录是Redhet 与CentOS 所特有的目录，是一个安全机制，类似于防火墙。</li><li>&#x2F;srv ：service 的缩写，该目录存放一些服务启动之后需要提取的数据。</li><li>&#x2F;sys ：该目录下安装了2.6 内核中新出现的一个文件系统sysfs。</li><li>&#x2F;tmp ：该目录用来存放一些临时文件。</li><li>&#x2F;usr ：很重要的一个目录，用户的很多应用程序和文件都放在这个目录下。类似于Windows 中的program files 目录。</li><li>&#x2F;var ：这个目录存放着在不断被扩充的文件。我们习惯将那些经常需要被修改的文件放在该目录下，比如一些日志文件等。</li></ul><p><em><strong>3、了解文件权限</strong></em><br>作为小白的你往往不会自己去写shell脚本，经常去网上找别人写好的相同功能的脚本，这时你下载下来准备执行的时候发现无法执行。</p><ul><li>这是为什么呢？这是因为改为鉴不具备执行权限所以无法运行。</li><li>这个时候我们就需要简单的了解一下文件的权限<br>可能权限就像下面这样：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-     rw-    r--    r--</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么如何更改文件的权限呢？<br>这个时候我们就需要chmod命令了<br>语法<br>chmod [-cfvR] [–help] [–version] mode file…<br>参数说明<br>mode : 权限设定字串，格式如下 :</p><p>[ugoa…][[+-&#x3D;][rwxX]…][,…]<br>其中：</p><p>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</p><ul><li>表示增加权限、- 表示取消权限、&#x3D; 表示唯一设定权限。<br>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。<br>其他参数说明：</li></ul><p>-c : 若该文件权限确实已经更改，才显示其更改动作<br>-f : 若该文件权限无法被更改也不要显示错误讯息<br>-v : 显示权限变更的详细资料<br>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)<br>–help : 显示辅助说明<br>–version : 显示版本<br><strong>实例：</strong><br>将文件 file1.txt 设为所有人皆可读取 :<br>chmod ugo+r file1.txt</p><p>将文件 file1.txt 设为所有人皆可读取 :<br>chmod a+r file1.txt</p><p>将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :<br>chmod ug+w,o-w file1.txt file2.txt</p><p>将 ex1.py 设定为只有该文件拥有者可以执行 :<br>chmod u+x ex1.py</p><p>将目前目录下的所有文件与子目录皆设为任何人可读取 :<br>chmod -R a+r *</p><p>此外chmod也可以用数字来表示权限如 :<br>chmod 777 file</p><p>语法为：<br>chmod abc file<br>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。</p><p>r&#x3D;4，w&#x3D;2，x&#x3D;1<br>若要rwx属性则4+2+1&#x3D;7；<br>若要rw-属性则4+2&#x3D;6；<br>若要r-x属性则4+1&#x3D;5。<br>chmod a&#x3D;rwx file和chmod 777 file效果相同<br>chmod ug&#x3D;rwx,o&#x3D;x file和chmod 771 file效果相同<br>若用chmod 4755 filename可使此程序具有root的权限</p><p><em><strong>好了说了那么多，直接一点吧！！！</strong></em><br>我们简单一点比如我们的操作对象为 a.sh<br>想要赋予执行权限直接可以用chmod +x a.sh即可<br>然后就可以快乐的用.&#x2F;a.sh跑脚本了。</p>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Termius </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小白玩转Linux的必备技能——入门篇</title>
      <link href="/post/2018/07/18/64524/"/>
      <url>/post/2018/07/18/64524/</url>
      
        <content type="html"><![CDATA[<p>本人主业是开发业余时间喜欢研究运维方面的东西，对这方面还算小有心得，不算太小白。</p><p>Linux系统常用的两个系列分别是RedHat系和Debian系。RedHat系中常用的一般是CentOS，而Debian系中常用的一般是Ubuntu。</p><p>我先列出如下两点，这样入门就基本没问题了。</p><h4 id="如下："><a href="#如下：" class="headerlink" title="如下："></a>如下：</h4><p><em><strong>1、了解Linux系统基础命令</strong></em></p><p>这个不用说了，是基础中的基础，常见的命令和知识点肯定是要了解的，没必须啥命令都记住，但基本常见的命令总得会吧。<br>推荐一本电子书：The Linux Command Line</p><p><em><strong>2、选择一个称手的SSH工具</strong></em></p><h2 id="工欲善其事，必先利其器！SSH工具有很多。推荐我常用的两个win和mac平台通用的：-————-该软件好像是国内个人开发者开发的，我平时用来连连测试服务器，不敢用来连接生产服务器。毕竟这个是国产闭源的哈-不敢瞎搞）"><a href="#工欲善其事，必先利其器！SSH工具有很多。推荐我常用的两个win和mac平台通用的：-————-该软件好像是国内个人开发者开发的，我平时用来连连测试服务器，不敢用来连接生产服务器。毕竟这个是国产闭源的哈-不敢瞎搞）" class="headerlink" title="工欲善其事，必先利其器！SSH工具有很多。推荐我常用的两个win和mac平台通用的：- ————  该软件好像是国内个人开发者开发的，我平时用来连连测试服务器，不敢用来连接生产服务器。毕竟这个是国产闭源的哈 不敢瞎搞）"></a>工欲善其事，必先利其器！SSH工具有很多。推荐我常用的两个win和mac平台通用的：<br>- <strong>——<em><mark class="hl-label blue">finalshell</mark> </em>——</strong><br>  该软件好像是国内个人开发者开发的，我平时用来连连测试服务器，不敢用来连接生产服务器。毕竟这个是国产闭源的哈 不敢瞎搞）</h2><h2 id="Windows版下载地址"><a href="#Windows版下载地址" class="headerlink" title="  Windows版下载地址"></a>  <a href="http://www.hostbuf.com/downloads/finalshell_install.exe">Windows版下载地址</a></h2><p>  <a href="http://www.hostbuf.com/downloads/finalshell_install.pkg">macOS版下载地址</a></p><ul><li><strong>——<em><mark class="hl-label blue">Termius</mark> </em>——</strong><br>可能大部分人都听说过MobaXterm和XShell，称它们为Windows平台最好用的两个终端工具不为过吧【特别是MobaXterm贼好用】。 <strong>但是</strong> 唯一不足的地方就是它只有Windows版本。所以今天跟大家介绍一款全平台的远程终端——Termius。Termius不仅涵盖了Windows、Linux、OSX，还变态得支持Android和iOS（以后在地铁、公交上都可以随时拿出手机来排查线上问题啦，还真是广大码农、运维的福音呢）。<br>Termius官网：<br><a href="https://termius.com/">https://termius.com/</a><br><strong>注意</strong>：此软件的云同步等高级功能为付费功能，但是可以通过edu渠道免费使用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Termius </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL5.7版本sql_mode=only_full_group_by问题</title>
      <link href="/post/2017/08/02/47261/"/>
      <url>/post/2017/08/02/47261/</url>
      
        <content type="html"><![CDATA[<h3 id="最近接了个项目，因为项目要与第三方协作的原因需要用到mysql5-7-x版本。然后就碰到了这个新老版本的差异导致的group-by问题。"><a href="#最近接了个项目，因为项目要与第三方协作的原因需要用到mysql5-7-x版本。然后就碰到了这个新老版本的差异导致的group-by问题。" class="headerlink" title="最近接了个项目，因为项目要与第三方协作的原因需要用到mysql5.7.x版本。然后就碰到了这个新老版本的差异导致的group by问题。"></a>最近接了个项目，因为项目要与第三方协作的原因需要用到mysql5.7.x版本。然后就碰到了这个新老版本的差异导致的group by问题。</h3><p>mysql5.7.x版本默认是开启了 only_full_group_by 模式的，但开启这个模式后，原先的 group by 语句就报错，然后又把它移除了。<br>一旦开启 only_full_group_by，感觉group by将变成和distinct一样，只能获取受到其影响的字段信息，无法和其他未受其影响的字段共存，这样group by的功能将变得十分鸡肋了！</p><h3 id="具体出错提示："><a href="#具体出错提示：" class="headerlink" title="具体出错提示："></a>具体出错提示：</h3><p>[Err] 1055 - Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column ‘information_schema.PROFILING.SEQ’ which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode&#x3D;only_full_group_by</p><h3 id="解决方式如下："><a href="#解决方式如下：" class="headerlink" title="解决方式如下："></a>解决方式如下：</h3><p><em><strong>1、在sql查询语句中不需要group by的字段上使用any_value()函数</strong></em><br>什么？改代码？ 改代码是不可能的这辈子都不可能！！！这种对于已经开发完成的项目不太合适，毕竟要把原来的sql都给修改一遍！</p><p><em><strong>2、修改my.cnf（windows下是my.ini）配置文件，删掉only_full_group_by这一项</strong></em><br>若我们项目的mysql安装在Debian上面，找到这个文件打开一看，里面并没有sql_mode这一配置项，想删都没得删。<br><strong>那该怎么办呢</strong><br>当然，还有别的办法，打开mysql命令行，执行命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">select @@global.sql_mode;</span><br></pre></td></tr></table></figure><p>查询出来的结果一般是这个：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br></pre></td></tr></table></figure><p>我们将ONLY_FULL_GROUP_BY去掉重新设置值即可：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> @@global.sql_mode =<span class="string">&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面是改变了全局sql_mode，只对新建的数据库有效。对于已存在的数据库，则需要在对应的数据下执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> sql_mode =<span class="string">&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这样就大功告成了！</p>]]></content>
      
      
      <categories>
          
          <category> 安全与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
